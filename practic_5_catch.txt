Практическое введение в обработку ошибок в Go
Теоретическое введение
Цель урока: Научиться правильно обрабатывать ошибки в Go, понимать философию обработки ошибок и использовать современные практики.

Концепция: В Go нет исключений (exceptions) как в других языках. Вместо этого функции возвращают ошибки как обычные значения. Это делает обработку ошибок явной и предсказуемой.

Философия обработки ошибок в Go:
Ошибки — это значения
Обработка ошибок — это часть нормального потока выполнения
Проверяйте ошибки сразу после вызова функции
Предоставляйте контекст при передаче ошибок выше
Паника (panic) — только для действительно исключительных ситуаций

Шаг 1: Основы обработки ошибок
Цель: Научиться базовым техникам обработки ошибок: проверка, создание и возврат ошибок.

Теория:
Тип error — это встроенный интерфейс: type error interface { Error() string }
Ошибки создаются с помощью errors.New() или fmt.Errorf()
Ошибки проверяются сразу после вызова функции
Множественные возвращаемые значения часто включают ошибку последним

Практика:
go
package main

import (
    "errors"
    "fmt"
    "strconv"
    "strings"
)

// Функция, возвращающая ошибку в качестве последнего значения
func делить(делимое, делитель int) (int, error) {
    if делитель == 0 {
        return 0, errors.New("деление на ноль")
    }
    return делимое / делитель, nil
}

// Функция с более информативной ошибкой
func извлечьЧисло(строка string) (int, error) {
    // Убираем пробелы
    строка = strings.TrimSpace(строка)
    
    if строка == "" {
        return 0, errors.New("пустая строка")
    }
    
    число, err := strconv.Atoi(строка)
    if err != nil {
        return 0, fmt.Errorf("не удалось преобразовать '%s' в число: %v", строка, err)
    }
    
    if число < 0 {
        return 0, fmt.Errorf("число %d отрицательное, ожидалось положительное", число)
    }
    
    return число, nil
}

// Функция с множественными проверками
func зарегистрироватьПользователя(имя, email string, возраст int) (int, error) {
    // Проверка имени
    имя = strings.TrimSpace(имя)
    if имя == "" {
        return 0, errors.New("имя не может быть пустым")
    }
    if len(имя) < 2 {
        return 0, errors.New("имя должно быть не короче 2 символов")
    }
    
    // Проверка email
    email = strings.TrimSpace(email)
    if email == "" {
        return 0, errors.New("email не может быть пустым")
    }
    if !strings.Contains(email, "@") {
        return 0, errors.New("неверный формат email")
    }
    
    // Проверка возраста
    if возраст < 18 {
        return 0, fmt.Errorf("возраст %d меньше минимального (18)", возраст)
    }
    if возраст > 120 {
        return 0, fmt.Errorf("возраст %d нереалистичный", возраст)
    }
    
    // Имитация успешной регистрации
    id := 1001
    return id, nil
}

func main() {
    fmt.Println("=== Основы обработки ошибок ===")
    
    // Пример 1: Деление с проверкой ошибок
    fmt.Println("\n1. Деление чисел:")
    
    результатов, err := делить(10, 2)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Printf("10 / 2 = %d\n", результатов)
    }
    
    результатов, err = делить(10, 0)
    if err != nil {
        fmt.Printf("Ошибка при делении 10 на 0: %v\n", err)
    } else {
        fmt.Printf("10 / 0 = %d\n", результатов)
    }
    
    // Пример 2: Извлечение числа из строки
    fmt.Println("\n2. Извлечение чисел из строк:")
    
    тестовыеСтроки := []string{"42", "  123  ", "-5", "abc", ""}
    
    for _, строка := range тестовыеСтроки {
        число, err := извлечьЧисло(строка)
        if err != nil {
            fmt.Printf("Ошибка для '%s': %v\n", строка, err)
        } else {
            fmt.Printf("Успех для '%s': %d\n", строка, число)
        }
    }
    
    // Пример 3: Регистрация пользователя
    fmt.Println("\n3. Регистрация пользователей:")
    
    тестовыеПользователи := []struct {
        имя   string
        email string
        возраст int
    }{
        {"Анна", "anna@example.com", 25},
        {"А", "anna@example.com", 25}, // Слишком короткое имя
        {"", "anna@example.com", 25},  // Пустое имя
        {"Борис", "boris.example.com", 30}, // Неверный email
        {"Виктор", "viktor@example.com", 16}, // Слишком молод
        {"Дарья", "darya@example.com", 150}, // Нереалистичный возраст
    }
    
    for _, пользователь := range тестовыеПользователи {
        id, err := зарегистрироватьПользователя(пользователь.имя, пользователь.email, пользователь.возраст)
        if err != nil {
            fmt.Printf("Ошибка регистрации %s: %v\n", пользователь.имя, err)
        } else {
            fmt.Printf("Пользователь %s зарегистрирован с ID %d\n", пользователь.имя, id)
        }
    }
    
    // Паттерны обработки ошибок
    fmt.Println("\n=== Паттерны обработки ошибок ===")
    
    // Паттерн 1: Немедленная проверка ошибок
    fmt.Println("\nПаттерн 1: Немедленная проверка ошибок")
    
    // ПЛОХО: откладывание проверки ошибок
    // число, err := извлечьЧисло("42")
    // // ... много кода ...
    // if err != nil { ... }
    
    // ХОРОШО: немедленная проверка
    число, err := извлечьЧисло("42")
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
        return
    }
    fmt.Printf("Число: %d\n", число)
    
    // Паттерн 2: Обработка ошибок в цикле
    fmt.Println("\nПаттерн 2: Обработка ошибок в цикле")
    
    строкиДляОбработки := []string{"10", "20", "тридцать", "40", "пятьдесят"}
    сумма := 0
    ошибкиВЦикле := []string{}
    
    for _, строка := range строкиДляОбработки {
        значение, err := извлечьЧисло(строка)
        if err != nil {
            ошибкиВЦикле = append(ошибкиВЦикле, fmt.Sprintf("'%s': %v", строка, err))
            continue // Продолжаем обработку остальных элементов
        }
        сумма += значение
    }
    
    fmt.Printf("Сумма корректных значений: %d\n", сумма)
    if len(ошибкиВЦикле) > 0 {
        fmt.Println("Ошибки при обработке:")
        for _, ошибка := range ошибкиВЦикле {
            fmt.Printf("  - %s\n", ошибка)
        }
    }
    
    // Паттерн 3: Сворачивание ошибок
    fmt.Println("\nПаттерн 3: Сворачивание ошибок")
    
    // Вместо:
    // if err != nil {
    //     return err
    // }
    
    // Можно добавлять контекст:
    // if err != nil {
    //     return fmt.Errorf("не удалось выполнить операцию: %v", err)
    // }
}
Объяснение:
Тип error — встроенный интерфейс с методом Error() string.
Создание ошибок — errors.New("текст") или fmt.Errorf("формат", аргументы).
Проверка ошибок — всегда сразу после вызова функции.
nil для ошибок — означает отсутствие ошибки.

Добавление контекста — fmt.Errorf() позволяет добавлять информацию к ошибке.

Задание для самостоятельной работы 1:
Создайте функцию валидироватьПароль(пароль string) error, которая проверяет:

Длина не менее 8 символов
Содержит хотя бы одну цифру
Содержит хотя бы одну букву верхнего регистра
Содержит хотя бы одну букву нижнего регистра
Создайте функцию читатьКонфигурацию(путь string) (map[string]string, error), которая:
Проверяет существование файла
Проверяет, что файл не пустой
Парсит файл в формате "ключ=значение"
Напишите тесты для обеих функций

Шаг 2: Пользовательские типы ошибок
Цель: Научиться создавать пользовательские типы ошибок для более сложной логики обработки.

Теория:
Можно создавать собственные типы, реализующие интерфейс error
Пользовательские ошибки могут содержать дополнительные поля
Позволяют использовать проверки типов (type assertion, type switch)
Позволяют реализовать более сложное поведение

Практика:
go
package main

import (
    "fmt"
    "strings"
    "time"
)

// Пользовательская ошибка с дополнительными полями
type ОшибкаВалидации struct {
    Поле     string
    Значение interface{}
    Сообщение string
}

// Реализация интерфейса error
func (о *ОшибкаВалидации) Error() string {
    return fmt.Sprintf("ошибка валидации поля '%s' (значение: %v): %s", 
        о.Поле, о.Значение, о.Сообщение)
}

// Пользовательская ошибка для сетевых операций
type СетеваяОшибка struct {
    Операция   string
    КодОшибки  int
    ВремяОшибки time.Time
    ВнутренняяОшибка error
}

func (с *СетеваяОшибка) Error() string {
    сообщение := fmt.Sprintf("сетевая ошибка при операции '%s' (код: %d) в %v", 
        с.Операция, с.КодОшибки, с.ВремяОшибки.Format("15:04:05"))
    
    if с.ВнутренняяОшибка != nil {
        сообщение += fmt.Sprintf(": %v", с.ВнутренняяОшибка)
    }
    
    return сообщение
}

// Метод для проверки, является ли ошибка временной
func (с *СетеваяОшибка) Временная() bool {
    // Некоторые коды ошибок могут быть временными
    временныеКоды := map[int]bool{
        408: true, // Request Timeout
        429: true, // Too Many Requests
        502: true, // Bad Gateway
        503: true, // Service Unavailable
        504: true, // Gateway Timeout
    }
    
    return временныеКоды[с.КодОшибки]
}

// Ошибка для бизнес-логики
type БизнесОшибка struct {
    Код         string
    Сообщение   string
    Рекомендация string
}

func (б *БизнесОшибка) Error() string {
    return fmt.Sprintf("[%s] %s. Рекомендация: %s", 
        б.Код, б.Сообщение, б.Рекомендация)
}

// Функции для создания типизированных ошибок
func НовыйНедостаточноСредств(баланс, требуется float64) *БизнесОшибка {
    return &БизнесОшибка{
        Код:         "INSUFFICIENT_FUNDS",
        Сообщение:   fmt.Sprintf("недостаточно средств: баланс %.2f, требуется %.2f", баланс, требуется),
        Рекомендация: "пополните счет или уменьшите сумму операции",
    }
}

func НовыйПользовательНеНайден(идентификатор interface{}) *БизнесОшибка {
    return &БизнесОшибка{
        Код:         "USER_NOT_FOUND",
        Сообщение:   fmt.Sprintf("пользователь с идентификатором %v не найден", идентификатор),
        Рекомендация: "проверьте правильность идентификатора",
    }
}

// Пример использования пользовательских ошибок
func обработатьПлатеж(отправительID, получательID int, сумма float64) error {
    // Имитация проверки баланса
    балансОтправителя := 100.0
    
    if балансОтправителя < сумма {
        return НовыйНедостаточноСредств(балансОтправителя, сумма)
    }
    
    // Имитация проверки получателя
    if получательID == 999 {
        return НовыйПользовательНеНайден(получательID)
    }
    
    // Имитация успешной операции
    fmt.Printf("Платеж %.2f от %d к %d выполнен успешно\n", сумма, отправительID, получательID)
    return nil
}

func валидироватьПользователя(имя string, возраст int, email string) error {
    ошибки := []*ОшибкаВалидации{}
    
    // Валидация имени
    имя = strings.TrimSpace(имя)
    if имя == "" {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "имя",
            Значение: имя,
            Сообщение: "не может быть пустым",
        })
    } else if len(имя) < 2 {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "имя",
            Значение: имя,
            Сообщение: "должно быть не короче 2 символов",
        })
    }
    
    // Валидация возраста
    if возраст < 0 {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "возраст",
            Значение: возраст,
            Сообщение: "не может быть отрицательным",
        })
    } else if возраст < 18 {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "возраст",
            Значение: возраст,
            Сообщение: "должен быть не менее 18 лет",
        })
    }
    
    // Валидация email
    email = strings.TrimSpace(email)
    if email == "" {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "email",
            Значение: email,
            Сообщение: "не может быть пустым",
        })
    } else if !strings.Contains(email, "@") {
        ошибки = append(ошибки, &ОшибкаВалидации{
            Поле:     "email",
            Значение: email,
            Сообщение: "должен содержать символ @",
        })
    }
    
    // Если есть ошибки, возвращаем их
    if len(ошибки) > 0 {
        // Можно вернуть первую ошибку или создать составную ошибку
        // Для простоты вернем первую ошибку
        return ошибки[0]
    }
    
    return nil
}

func main() {
    fmt.Println("=== Пользовательские типы ошибок ===")
    
    // Пример 1: Валидация с пользовательскими ошибками
    fmt.Println("\n1. Валидация пользователя:")
    
    тестовыеДанные := []struct {
        имя   string
        возраст int
        email string
    }{
        {"Анна", 25, "anna@example.com"},
        {"", 25, "anna@example.com"},
        {"А", 25, "anna@example.com"},
        {"Борис", -5, "boris@example.com"},
        {"Виктор", 16, "viktor@example.com"},
        {"Дарья", 30, "daryaexample.com"}, // Нет @
    }
    
    for i, данные := range тестовыеДанные {
        fmt.Printf("\nТест %d: %s, %d, %s\n", i+1, данные.имя, данные.возраст, данные.email)
        
        err := валидироватьПользователя(данные.имя, данные.возраст, данные.email)
        if err != nil {
            fmt.Printf("  Ошибка: %v\n", err)
            
            // Проверка типа ошибки
            if ошибкаВалидации, ok := err.(*ОшибкаВалидации); ok {
                fmt.Printf("  Тип: ОшибкаВалидации, поле: %s\n", ошибкаВалидации.Поле)
            }
        } else {
            fmt.Println("  Успешно!")
        }
    }
    
    // Пример 2: Бизнес-ошибки
    fmt.Println("\n2. Обработка платежей:")
    
    тестовыеПлатежи := []struct {
        отправитель int
        получатель  int
        сумма       float64
    }{
        {1, 2, 50.0},
        {1, 2, 150.0}, // Недостаточно средств
        {1, 999, 50.0}, // Получатель не найден
    }
    
    for _, платеж := range тестовыеПлатежи {
        fmt.Printf("\nПлатеж: %d -> %d, сумма: %.2f\n", 
            платеж.отправитель, платеж.получатель, платеж.сумма)
        
        err := обработатьПлатеж(платеж.отправитель, платеж.получатель, платеж.сумма)
        if err != nil {
            fmt.Printf("  Ошибка: %v\n", err)
            
            // Проверка типа ошибки
            switch e := err.(type) {
            case *БизнесОшибка:
                fmt.Printf("  Тип: БизнесОшибка, код: %s\n", e.Код)
            default:
                fmt.Printf("  Неизвестный тип ошибки\n")
            }
        }
    }
    
    // Пример 3: Сетевые ошибки
    fmt.Println("\n3. Сетевые ошибки:")
    
    сетевыеОшибки := []error{
        &СетеваяОшибка{
            Операция:   "GET /api/data",
            КодОшибки:  200,
            ВремяОшибки: time.Now(),
        },
        &СетеваяОшибка{
            Операция:   "POST /api/update",
            КодОшибки:  503,
            ВремяОшибки: time.Now(),
            ВнутренняяОшибка: errors.New("connection refused"),
        },
        &СетеваяОшибка{
            Операция:   "DELETE /api/resource",
            КодОшибки:  429,
            ВремяОшибки: time.Now(),
        },
    }
    
    for _, ошибка := range сетевыеОшибки {
        fmt.Printf("\nОшибка: %v\n", ошибка)
        
        if сетевОшибка, ok := ошибка.(*СетеваяОшибка); ok {
            fmt.Printf("  Операция: %s\n", сетевОшибка.Операция)
            fmt.Printf("  Код: %d\n", сетевОшибка.КодОшибки)
            fmt.Printf("  Временная: %v\n", сетевОшибка.Временная())
        }
    }
    
    // Проверка типа ошибки с type switch
    fmt.Println("\n4. Проверка типа ошибки с type switch:")
    
    ошибкиДляАнализа := []error{
        errors.New("простая ошибка"),
        &ОшибкаВалидации{Поле: "email", Значение: "test", Сообщение: "неверный формат"},
        НовыйНедостаточноСредств(50.0, 100.0),
        &СетеваяОшибка{Операция: "connect", КодОшибки: 408, ВремяОшибки: time.Now()},
    }
    
    for _, err := range ошибкиДляАнализа {
        fmt.Printf("\nАнализ ошибки: %v\n", err)
        
        switch e := err.(type) {
        case *ОшибкаВалидации:
            fmt.Printf("  Это ошибка валидации поля '%s'\n", e.Поле)
        case *БизнесОшибка:
            fmt.Printf("  Это бизнес-ошибка с кодом '%s'\n", e.Код)
        case *СетеваяОшибка:
            fmt.Printf("  Это сетевая ошибка, временная: %v\n", e.Временная())
        default:
            fmt.Printf("  Это ошибка другого типа\n")
        }
    }
}

Объяснение:
Пользовательские типы ошибок — структуры с методом Error() string.
Дополнительные поля — позволяют хранить больше информации об ошибке.
Проверка типов — err.(*ТипОшибки) или type switch.
Дополнительные методы — можно добавлять методы к пользовательским ошибкам.
Составные ошибки — ошибки могут содержать другие ошибки.

Задание для самостоятельной работы 2:
Создайте тип ОшибкаБазыДанных с полями:
Запрос (string)
КодОшибки (int)
Детали (string)
ВнутренняяОшибка (error)
Добавьте метод Восстановимая() bool, который возвращает true для определенных кодов ошибок
Создайте функцию выполнитьЗапрос(запрос string) (результат string, ошибка error), которая возвращает ОшибкаБазыДанных в случае ошибки
Реализуйте логику повторных попыток для восстановимых ошибок

Шаг 3: Обертывание ошибок (Go 1.13+)
Цель: Научиться использовать обертывание ошибок для создания цепочек ошибок с сохранением контекста.

Теория:
Go 1.13 добавил поддержку обертывания ошибок
fmt.Errorf() с директивой %w оборачивает ошибку
Функции errors.Is() и errors.As() для работы с обернутыми ошибками
Позволяет создавать цепочки ошибок с сохранением контекста

Практика:
go
package main

import (
    "errors"
    "fmt"
    "io/fs"
    "os"
    "strings"
)

// Базовая ошибка для нашего примера
var (
    ErrПользовательНеНайден = errors.New("пользователь не найден")
    ErrНедостаточноПрав     = errors.New("недостаточно прав")
    ErrНеверныйФормат       = errors.New("неверный формат данных")
)

// Функции, которые могут возвращать обернутые ошибки
func найтиПользователя(id int) (string, error) {
    // Имитация поиска в базе данных
    if id < 0 {
        return "", fmt.Errorf("неверный ID пользователя: %d", id)
    }
    
    if id == 999 {
        return "", fmt.Errorf("не удалось найти пользователя %d: %w", id, ErrПользовательНеНайден)
    }
    
    if id == 777 {
        return "", fmt.Errorf("ошибка доступа для пользователя %d: %w", id, ErrНедостаточноПрав)
    }
    
    return fmt.Sprintf("Пользователь_%d", id), nil
}

func обработатьЗапрос(id int) error {
    пользователь, err := найтиПользователя(id)
    if err != nil {
        // Оборачиваем ошибку с добавлением контекста
        return fmt.Errorf("не удалось обработать запрос для ID %d: %w", id, err)
    }
    
    fmt.Printf("Обработан запрос для: %s\n", пользователь)
    return nil
}

func выполнитьОперацию(id int) error {
    if err := обработатьЗапрос(id); err != nil {
        // Еще один уровень обертывания
        return fmt.Errorf("сбой выполнения операции: %w", err)
    }
    
    return nil
}

// Пример с файловой системой
func прочитатьКонфигурацию(путь string) (string, error) {
    данные, err := os.ReadFile(путь)
    if err != nil {
        // Обертываем стандартную ошибку файловой системы
        return "", fmt.Errorf("не удалось прочитать конфигурацию из '%s': %w", путь, err)
    }
    
    содержимое := string(данные)
    if strings.TrimSpace(содержимое) == "" {
        return "", fmt.Errorf("файл конфигурации '%s' пустой: %w", путь, ErrНеверныйФормат)
    }
    
    return содержимое, nil
}

// Пример с пользовательской ошибкой
type МояОшибка struct {
    Код    int
    Сообщение string
}

func (м *МояОшибка) Error() string {
    return fmt.Sprintf("[%d] %s", м.Код, м.Сообщение)
}

func функцияСМоейОшибкой() error {
    // Создаем и оборачиваем пользовательскую ошибку
    ошибка := &МояОшибка{Код: 42, Сообщение: "что-то пошло не так"}
    return fmt.Errorf("дополнительный контекст: %w", ошибка)
}

func main() {
    fmt.Println("=== Обертывание ошибок (Go 1.13+) ===")
    
    // Пример 1: Проверка обернутых ошибок с errors.Is()
    fmt.Println("\n1. Проверка обернутых ошибок с errors.Is():")
    
    тестовыеID := []int{1, 999, 777, -5}
    
    for _, id := range тестовыеID {
        fmt.Printf("\nТест для ID %d:\n", id)
        
        err := выполнитьОперацию(id)
        if err != nil {
            fmt.Printf("  Ошибка: %v\n", err)
            
            // Проверка, содержит ли цепочка ошибок определенную ошибку
            if errors.Is(err, ErrПользовательНеНайден) {
                fmt.Println("  → Это ошибка 'пользователь не найден'")
            }
            
            if errors.Is(err, ErrНедостаточноПрав) {
                fmt.Println("  → Это ошибка 'недостаточно прав'")
            }
            
            // Проверка на наличие определенной строки в сообщении
            if strings.Contains(err.Error(), "неверный ID") {
                fmt.Println("  → Содержит 'неверный ID'")
            }
        } else {
            fmt.Println("  Успешно!")
        }
    }
    
    // Пример 2: Извлечение обернутой ошибки с errors.As()
    fmt.Println("\n2. Извлечение обернутой ошибки с errors.As():")
    
    err := функцияСМоейОшибкой()
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
        
        // Попытка извлечь МояОшибка из цепочки
        var мояОшибка *МояОшибка
        if errors.As(err, &мояОшибка) {
            fmt.Printf("Найдена МояОшибка: код=%d, сообщение='%s'\n", 
                мояОшибка.Код, мояОшибка.Сообщение)
        } else {
            fmt.Println("МояОшибка не найдена в цепочке")
        }
    }
    
    // Пример 3: Работа с файловой системой
    fmt.Println("\n3. Работа с файловой системой:")
    
    тестовыеФайлы := []string{
        "существующий_файл.txt",
        "несуществующий_файл.txt",
        "пустой_файл.txt",
    }
    
    // Создадим тестовые файлы
    os.WriteFile("существующий_файл.txt", []byte("конфигурация=значение"), 0644)
    os.WriteFile("пустой_файл.txt", []byte(""), 0644)
    defer os.Remove("существующий_файл.txt")
    defer os.Remove("пустой_файл.txt")
    
    for _, файл := range тестовыеФайлы {
        fmt.Printf("\nЧтение файла '%s':\n", файл)
        
        содержимое, err := прочитатьКонфигурацию(файл)
        if err != nil {
            fmt.Printf("  Ошибка: %v\n", err)
            
            // Проверка на стандартные ошибки файловой системы
            if errors.Is(err, fs.ErrNotExist) {
                fmt.Println("  → Файл не существует")
            }
            
            if errors.Is(err, ErrНеверныйФормат) {
                fmt.Println("  → Неверный формат данных")
            }
            
            // Проверка на наличие определенной строки
            if strings.Contains(err.Error(), "не удалось прочитать") {
                fmt.Println("  → Ошибка чтения файла")
            }
        } else {
            fmt.Printf("  Успешно! Содержимое: %s\n", содержимое)
        }
    }
    
    // Пример 4: Разворачивание цепочки ошибок
    fmt.Println("\n4. Разворачивание цепочки ошибок:")
    
    // Создаем глубокую цепочку ошибок
    базоваяОшибка := errors.New("базовая ошибка")
    обернутая1 := fmt.Errorf("уровень 1: %w", базоваяОшибка)
    обернутая2 := fmt.Errorf("уровень 2: %w", обернутая1)
    обернутая3 := fmt.Errorf("уровень 3: %w", обернутая2)
    
    fmt.Printf("Итоговая ошибка: %v\n", обернутая3)
    
    // Проверяем всю цепочку
    fmt.Println("\nРазворачиваем цепочку:")
    текущая := обернутая3
    for i := 1; текущая != nil; i++ {
        fmt.Printf("  Уровень %d: %v\n", i, текущая)
        
        // Получаем следующую ошибку в цепочке
        следующая := errors.Unwrap(текущая)
        if следующая == nil {
            break
        }
        текущая = следующая
    }
    
    // Проверяем, содержит ли цепочка базовую ошибку
    if errors.Is(обернутая3, базоваяОшибка) {
        fmt.Println("\nЦепочка содержит базовую ошибку")
    }
    
    // Практический пример: повторные попытки при временных ошибках
    fmt.Println("\n5. Практический пример: повторные попытки:")
    
    временнаяОшибка := &СетеваяОшибка{Операция: "запрос", КодОшибки: 503, ВремяОшибки: time.Now()}
    обернутаяОшибка := fmt.Errorf("не удалось выполнить операцию: %w", временнаяОшибка)
    
    fmt.Printf("Ошибка: %v\n", обернутаяОшибка)
    
    // Проверяем, является ли ошибка временной
    var сетевОшибка *СетеваяОшибка
    if errors.As(обернутаяОшибка, &сетевОшибка) {
        if сетевОшибка.Временная() {
            fmt.Println("Ошибка временная, можно повторить")
        } else {
            fmt.Println("Ошибка не временная, не повторять")
        }
    }
}

Объяснение:
%w в fmt.Errorf() — оборачивает ошибку, сохраняя исходную ошибку.
errors.Is(err, target) — проверяет, содержит ли цепочка ошибок целевую ошибку.
errors.As(err, target) — пытается извлечь ошибку определенного типа из цепочки.
errors.Unwrap(err) — возвращает следующую ошибку в цепочке.
Цепочки ошибок — позволяют сохранять контекст и исходные ошибки.

Задание для самостоятельной работы 3:
Создайте функцию загрузитьДанные(источник string) (данные string, ошибка error), которая:
Пытается загрузить данные из разных источников (файл, сеть, кэш)
Обертывает ошибки с контекстом источника
Возвращает цепочку ошибок при неудаче
Реализуйте функцию обработатьПользовательскийВвод(ввод string) (результат string, ошибка error) с валидацией:
Проверка формата
Проверка длины
Проверка содержимого
Используйте errors.Is() для проверки типов ошибок
Напишите тесты для проверки обертывания ошибок

Шаг 4: Паника (panic) и восстановление (recover)
Цель: Научиться правильно использовать panic и recover для обработки действительно исключительных ситуаций.

Теория:
panic — вызывает аварийную остановку программы
recover — позволяет перехватить панику и продолжить выполнение
В Go panic не следует использовать для обычной обработки ошибок
Panic предназначен для действительно невосстановимых ошибок
recover работает только внутри отложенных функций (defer)

Практика:
go
package main

import (
    "fmt"
    "runtime/debug"
)

// НЕПРАВИЛЬНОЕ использование panic
func неправильныйПример(число int) {
    if число < 0 {
        panic("число не может быть отрицательным") // НЕ ДЕЛАЙТЕ ТАК!
    }
    fmt.Printf("Число: %d\n", число)
}

// ПРАВИЛЬНАЯ обработка ошибок
func правильныйПример(число int) error {
    if число < 0 {
        return fmt.Errorf("число %d отрицательное", число)
    }
    fmt.Printf("Число: %d\n", число)
    return nil
}

// Panic для действительно исключительных ситуаций
func критическаяОперация() {
    // Имитация критической ошибки
    panic("критическая ошибка: потеряно соединение с базой данных")
}

// Безопасный вызов критической операции
func безопасноВыполнить(fn func()) (err error) {
    // Восстановление после паники
    defer func() {
        if r := recover(); r != nil {
            // Преобразуем панику в ошибку
            err = fmt.Errorf("паника перехвачена: %v", r)
            
            // Можно также логировать стек вызовов
            fmt.Println("Стек вызовов при панике:")
            debug.PrintStack()
        }
    }()
    
    fn() // Вызываем функцию, которая может запаниковать
    return nil
}

// Пример с делением на ноль
func безопасноеДеление(делимое, делитель int) (результат int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("ошибка при делении: %v", r)
        }
    }()
    
    // Это вызовет панику при делителе = 0
    результат = делимое / делитель
    return результат, nil
}

// Работа с паникой в горутинах
func выполнитьВГорутине() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Паника в горутине перехвачена: %v\n", r)
        }
    }()
    
    // Имитация паники в горутине
    panic("ошибка в горутине")
}

// Инициализация с восстановлением
func инициализировать() error {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Ошибка инициализации: %v\n", r)
        }
    }()
    
    // Имитация инициализации, которая может запаниковать
    выполнитьИнициализацию()
    
    return nil
}

func выполнитьИнициализацию() {
    // Имитация ошибки при инициализации
    panic("не удалось инициализировать компонент")
}

func main() {
    fmt.Println("=== Паника (panic) и восстановление (recover) ===")
    
    // Пример 1: Неправильное использование panic
    fmt.Println("\n1. Неправильное использование panic (так делать не стоит):")
    
    defer func() {
        fmt.Println("Эта функция выполнится даже после panic")
    }()
    
    // Восстановление после паники на верхнем уровне
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Паника перехвачена в main: %v\n", r)
            fmt.Println("Программа продолжает работу")
        }
    }()
    
    // Этот вызов вызовет панику, но мы восстановимся
    неправильныйПример(-5)
    fmt.Println("Это сообщение не выведется, если паника не перехвачена")
    
    // Пример 2: Правильная обработка ошибок
    fmt.Println("\n2. Правильная обработка ошибок (рекомендуемый способ):")
    
    err := правильныйПример(-5)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    }
    
    err = правильныйПример(10)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Println("Успешно!")
    }
    
    // Пример 3: Безопасное выполнение критических операций
    fmt.Println("\n3. Безопасное выполнение критических операций:")
    
    err = безопасноВыполнить(критическаяОперация)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    }
    
    fmt.Println("Программа продолжает работу после критической операции")
    
    // Пример 4: Безопасное деление
    fmt.Println("\n4. Безопасное деление:")
    
    результаты, err := безопасноеДеление(10, 2)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Printf("10 / 2 = %d\n", результаты)
    }
    
    результаты, err = безопасноеДеление(10, 0)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Printf("10 / 0 = %d\n", результаты)
    }
    
    // Пример 5: Паника в горутинах
    fmt.Println("\n5. Паника в горутинах:")
    
    go выполнитьВГорутине()
    
    // Даем время горутине выполниться
    fmt.Println("Главная горутина продолжает работу")
    
    // Ждем немного, чтобы горутина успела выполниться
    // В реальном коде нужно использовать sync.WaitGroup или каналы
    fmt.Scanln()
    
    // Пример 6: Инициализация с восстановлением
    fmt.Println("\n6. Инициализация с восстановлением:")
    
    err = инициализировать()
    if err != nil {
        fmt.Printf("Ошибка инициализации: %v\n", err)
    }
    
    fmt.Println("Программа продолжает работу после неудачной инициализации")
    
    // Когда использовать panic (правильно):
    fmt.Println("\n7. Когда правильно использовать panic:")
    
    правильныеСлучаи := []string{
        "1. Ошибки, которые невозможно обработать (например, нехватка памяти)",
        "2. Ошибки в функциях-инициализаторах (init), если они критичны",
        "3. Ошибки в тестах, которые должны прервать выполнение",
        "4. Программистские ошибки (например, передача nil в функцию, которая не ожидает nil)",
    }
    
    for _, случай := range правильныеСлучаи {
        fmt.Printf("  %s\n", случай)
    }
    
    // Пример: использование panic для программистских ошибок
    fmt.Println("\n8. Panic для программистских ошибок:")
    
    функцияТребуетНеNil := func(указатель interface{}) {
        if указатель == nil {
            panic("передан nil указатель")
        }
        fmt.Println("Обработка указателя...")
    }
    
    // Тестируем
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Перехвачена паника: %v\n", r)
        }
    }()
    
    var данные map[string]string
    функцияТребуетНеNil(данные) // Это вызовет панику
    
    данные = map[string]string{"ключ": "значение"}
    функцияТребуетНеNil(данные) // А это нет
}

Объяснение:
panic(value) — вызывает аварийную остановку, value может быть любого типа.
recover() — возвращает значение, переданное в panic(), работает только в defer.
defer — ключевое слово для отложенного выполнения, гарантирует выполнение даже при панике.
Стек вызовов — debug.PrintStack() выводит стек вызовов при панике.
Горутины и паника — каждая горутина должна перехватывать свою панику.

Задание для самостоятельной работы 4:
Создайте функцию безопасноВыполнитьСПовторами(fn func() error, попытки int) error, которая:
Выполняет функцию несколько раз при ошибках
Использует recover() для перехвата паник
Возвращает последнюю ошибку или панику
Реализуйте функцию загрузитьКонфигурациюБезопасно(путь string) (конфигурация map[string]string, ошибка error):
Использует panic/recover для критических ошибок парсинга
Возвращает ошибки для некритических проблем
Напишите тесты для функций с паникой и восстановлением

Шаг 5: Практические паттерны обработки ошибок
Цель: Изучить и применить практические паттерны обработки ошибок, используемые в реальных Go-проектах.

Теория:
Обработка ошибок должна быть идиоматичной и последовательной
Разные ситуации требуют разных подходов
Важно предоставлять достаточно контекста для отладки
Ошибки должны быть полезными для конечного пользователя

Практика:
go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
    "time"
)

// Паттерн 1: Ошибки с контекстом
func загрузитьКонфигурацию(путь string) (map[string]string, error) {
    файл, err := os.Open(путь)
    if err != nil {
        return nil, fmt.Errorf("не удалось открыть файл конфигурации '%s': %w", путь, err)
    }
    defer файл.Close()
    
    var конфигурация map[string]string
    декодер := json.NewDecoder(файл)
    if err := декодер.Decode(&конфигурация); err != nil {
        return nil, fmt.Errorf("не удалось декодировать JSON из '%s': %w", путь, err)
    }
    
    if len(конфигурация) == 0 {
        return nil, fmt.Errorf("файл конфигурации '%s' пустой", путь)
    }
    
    return конфигурация, nil
}

// Паттерн 2: Обработка нескольких ошибок
type МультиОшибка []error

func (м МультиОшибка) Error() string {
    if len(м) == 0 {
        return ""
    }
    if len(м) == 1 {
        return м[0].Error()
    }
    
    результат := fmt.Sprintf("%d ошибок:\n", len(м))
    for i, err := range м {
        результат += fmt.Sprintf("  %d. %v\n", i+1, err)
    }
    return результат
}

func валидироватьПользователяДетально(пользователь map[string]string) error {
    ошибки := МультиОшибка{}
    
    // Проверка имени
    if имя, ok := пользователь["имя"]; !ok || имя == "" {
        ошибки = append(ошибки, fmt.Errorf("поле 'имя' обязательно"))
    } else if len(имя) < 2 {
        ошибки = append(ошибки, fmt.Errorf("имя должно быть не короче 2 символов"))
    }
    
    // Проверка email
    if email, ok := пользователь["email"]; !ok || email == "" {
        ошибки = append(ошибки, fmt.Errorf("поле 'email' обязательно"))
    } else if !содержит(email, "@") {
        ошибки = append(ошибки, fmt.Errorf("email должен содержать @"))
    }
    
    // Проверка возраста
    if возрастСтр, ok := пользователь["возраст"]; ok && возрастСтр != "" {
        var возраст int
        if _, err := fmt.Sscanf(возрастСтр, "%d", &возраст); err != nil {
            ошибки = append(ошибки, fmt.Errorf("возраст должен быть числом"))
        } else if возраст < 0 {
            ошибки = append(ошибки, fmt.Errorf("возраст не может быть отрицательным"))
        } else if возраст < 18 {
            ошибки = append(ошибки, fmt.Errorf("возраст должен быть не менее 18 лет"))
        }
    }
    
    if len(ошибки) > 0 {
        return ошибки
    }
    
    return nil
}

// Вспомогательная функция
func содержит(s, substr string) bool {
    for i := 0; i <= len(s)-len(substr); i++ {
        if s[i:i+len(substr)] == substr {
            return true
        }
    }
    return false
}

// Паттерн 3: Повторные попытки с экспоненциальной отсрочкой
func выполнитьСПовторами(fn func() error, максПопытки int) error {
    var последняяОшибка error
    
    for попытка := 1; попытка <= максПопытки; попытка++ {
        err := fn()
        if err == nil {
            return nil // Успех
        }
        
        последняяОшибка = err
        
        // Экспоненциальная отсрочка
        if попытка < максПопытки {
            задержка := time.Duration(1<<uint(попытка-1)) * time.Second
            fmt.Printf("Попытка %d не удалась, ждем %v перед следующей попыткой\n", 
                попытка, задержка)
            time.Sleep(задержка)
        }
    }
    
    return fmt.Errorf("после %d попыток: %w", максПопытки, последняяОшибка)
}

// Паттерн 4: Ограничение времени выполнения
func выполнитьСТаймаутом(fn func() error, таймаут time.Duration) error {
    каналОшибок := make(chan error, 1)
    
    go func() {
        каналОшибок <- fn()
    }()
    
    select {
    case err := <-каналОшибок:
        return err
    case <-time.After(таймаут):
        return fmt.Errorf("таймаут операции (%v)", таймаут)
    }
}

// Паттерн 5: Логирование ошибок
type Логгер interface {
    Ошибка(format string, args ...interface{})
    Инфо(format string, args ...interface{})
}

type КонсольныйЛоггер struct{}

func (л КонсольныйЛоггер) Ошибка(format string, args ...interface{}) {
    fmt.Printf("[ERROR] "+format+"\n", args...)
}

func (л КонсольныйЛоггер) Инфо(format string, args ...interface{}) {
    fmt.Printf("[INFO] "+format+"\n", args...)
}

func обработатьЗапросСЛогированием(логгер Логгер, запрос map[string]string) error {
    логгер.Инфо("Начало обработки запроса")
    
    defer func() {
        if r := recover(); r != nil {
            логгер.Ошибка("Паника при обработке запроса: %v", r)
        }
    }()
    
    // Валидация
    if err := валидироватьПользователяДетально(запрос); err != nil {
        логгер.Ошибка("Ошибка валидации: %v", err)
        return err
    }
    
    // Имитация обработки
    времяОбработки := time.Duration(100+time.Now().UnixNano()%100) * time.Millisecond
    time.Sleep(времяОбработки)
    
    логгер.Инфо("Запрос успешно обработан за %v", времяОбработки)
    return nil
}

// Паттерн 6: HTTP обработка ошибок
func создатьHTTPОбработчик() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Восстановление после паники
        defer func() {
            if r := recover(); r != nil {
                http.Error(w, fmt.Sprintf("Внутренняя ошибка сервера: %v", r), 
                    http.StatusInternalServerError)
            }
        }()
        
        // Извлечение и валидация параметров
        имя := r.URL.Query().Get("имя")
        if имя == "" {
            http.Error(w, "Параметр 'имя' обязателен", http.StatusBadRequest)
            return
        }
        
        // Имитация обработки
        w.Header().Set("Content-Type", "application/json")
        ответ := map[string]string{
            "статус":  "успех",
            "сообщение": fmt.Sprintf("Привет, %s!", имя),
            "время":   time.Now().Format(time.RFC3339),
        }
        
        json.NewEncoder(w).Encode(ответ)
    }
}

func main() {
    fmt.Println("=== Практические паттерны обработки ошибок ===")
    
    // Паттерн 1: Ошибки с контекстом
    fmt.Println("\n1. Ошибки с контекстом:")
    
    конфигурация, err := загрузитьКонфигурацию("несуществующий_файл.json")
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
        
        // Проверка на конкретную ошибку
        if os.IsNotExist(err) {
            fmt.Println("Файл действительно не существует")
        }
    } else {
        fmt.Printf("Конфигурация: %v\n", конфигурация)
    }
    
    // Создадим тестовый файл
    тестоваяКонфигурация := map[string]string{"ключ": "значение"}
    данные, _ := json.Marshal(тестоваяКонфигурация)
    os.WriteFile("тест_конфиг.json", данные, 0644)
    defer os.Remove("тест_конфиг.json")
    
    конфигурация, err = загрузитьКонфигурацию("тест_конфиг.json")
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Printf("Конфигурация загружена: %v\n", конфигурация)
    }
    
    // Паттерн 2: Множественные ошибки
    fmt.Println("\n2. Множественные ошибки:")
    
    тестовыеПользователи := []map[string]string{
        {"имя": "А", "email": "test", "возраст": "-5"},
        {"имя": "Анна", "email": "anna@example.com", "возраст": "25"},
        {"email": "test@example.com"}, // Нет имени
        {"имя": "Борис", "возраст": "16"}, // Нет email, возраст меньше 18
    }
    
    for i, пользователь := range тестовыеПользователи {
        fmt.Printf("\nПользователь %d:\n", i+1)
        err := валидироватьПользователяДетально(пользователь)
        if err != nil {
            fmt.Printf("Ошибки валидации:\n%v\n", err)
            
            // Проверка типа ошибки
            if мультиОшибка, ok := err.(МультиОшибка); ok {
                fmt.Printf("Найдено %d ошибок валидации\n", len(мультиОшибка))
            }
        } else {
            fmt.Println("Валидация пройдена успешно")
        }
    }
    
    // Паттерн 3: Повторные попытки
    fmt.Println("\n3. Повторные попытки с экспоненциальной отсрочкой:")
    
    попытка := 0
    флаккующийСервис := func() error {
        попытка++
        if попытка < 3 {
            return fmt.Errorf("временная ошибка сервиса (попытка %d)", попытка)
        }
        return nil
    }
    
    err = выполнитьСПовторами(флаккующийСервис, 5)
    if err != nil {
        fmt.Printf("Ошибка после всех попыток: %v\n", err)
    } else {
        fmt.Println("Успешно после повторных попыток!")
    }
    
    // Паттерн 4: Ограничение времени выполнения
    fmt.Println("\n4. Ограничение времени выполнения:")
    
    медленнаяОперация := func() error {
        time.Sleep(2 * time.Second)
        return nil
    }
    
    err = выполнитьСТаймаутом(медленнаяОперация, 1*time.Second)
    if err != nil {
        fmt.Printf("Ошибка (ожидаемо): %v\n", err)
    } else {
        fmt.Println("Операция завершена успешно")
    }
    
    быстраяОперация := func() error {
        time.Sleep(100 * time.Millisecond)
        return nil
    }
    
    err = выполнитьСТаймаутом(быстраяОперация, 1*time.Second)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Println("Операция завершена успешно")
    }
    
    // Паттерн 5: Логирование ошибок
    fmt.Println("\n5. Логирование ошибок:")
    
    логгер := КонсольныйЛоггер{}
    
    тестовыеЗапросы := []map[string]string{
        {"имя": "Анна", "email": "anna@example.com", "возраст": "25"},
        {"имя": "А", "email": "неверный", "возраст": "-5"},
    }
    
    for i, запрос := range тестовыеЗапросы {
        fmt.Printf("\nОбработка запроса %d:\n", i+1)
        err := обработатьЗапросСЛогированием(логгер, запрос)
        if err != nil {
            fmt.Printf("Итоговая ошибка: %v\n", err)
        }
    }
    
    // Паттерн 6: HTTP обработка ошибок
    fmt.Println("\n6. HTTP обработка ошибок:")
    fmt.Println("Запустите сервер и откройте в браузере:")
    fmt.Println("  http://localhost:8080/hello?имя=Анна")
    fmt.Println("  http://localhost:8080/hello")
    fmt.Println("Нажмите Enter для продолжения...")
    
    go func() {
        http.HandleFunc("/hello", создатьHTTPОбработчик())
        http.ListenAndServe(":8080", nil)
    }()
    
    // Даем время серверу запуститься
    time.Sleep(100 * time.Millisecond)
    
    // Тестируем HTTP запросы
    тестироватьHTTPЗапрос := func(url string) {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Printf("Ошибка запроса: %v\n", err)
            return
        }
        defer resp.Body.Close()
        
        тело, _ := io.ReadAll(resp.Body)
        fmt.Printf("Ответ от %s:\nСтатус: %d\nТело: %s\n\n", 
            url, resp.StatusCode, тело)
    }
    
    тестироватьHTTPЗапрос("http://localhost:8080/hello?имя=Анна")
    тестироватьHTTPЗапрос("http://localhost:8080/hello")
}

Объяснение:
Ошибки с контекстом — добавляйте информацию о том, что происходило.
Множественные ошибки — собирайте все ошибки, а не только первую.
Повторные попытки — полезно для сетевых операций и ненадежных сервисов.
Таймауты — ограничивайте время выполнения операций.
Логирование — записывайте ошибки для последующего анализа.
HTTP обработка — возвращайте соответствующие коды состояния и сообщения.

Задание для самостоятельной работы 5:
Реализуйте функцию обработатьПакетДанных(данные []string) (результаты []string, ошибки []error), которая:
Обрабатывает каждый элемент независимо
Собирает успешные результаты
Собирает ошибки для неудачных элементов
Возвращает оба среза

Создайте систему валидации конфигурации с:
Проверкой обязательных полей
Проверкой типов данных
Проверкой допустимых значений
Поддержкой пользовательских правил валидации
Напишите middleware для HTTP-сервера, который:
Логирует все запросы и ответы
Восстанавливается после паник
Обрабатывает таймауты

Итоги урока
Что вы узнали:
Основы обработки ошибок — создание, проверка и возврат ошибок
Пользовательские типы ошибок — создание структурированных ошибок с дополнительной информацией
Обертывание ошибок — создание цепочек ошибок с сохранением контекста
Panic и recover — обработка действительно исключительных ситуаций
Практические паттерны — подходы для реальных приложений

Ключевые моменты:
Всегда проверяйте ошибки сразу после вызова функции
Добавляйте контекст к ошибкам при передаче их вверх по стеку вызовов
Используйте пользовательские типы ошибок для сложной логики обработки
Используйте errors.Is() и errors.As() для работы с обернутыми ошибками
Паника — только для действительно невосстановимых ошибок
Восстанавливайтесь из паник на границах модулей

Распространенные ошибки:
Игнорирование ошибок — _ = функция() (почти всегда неправильно)
Слишком общие ошибки — errors.New("ошибка") (не дает информации)
Утечка деталей реализации — не показывайте пользователям внутренние детали
Неправильное использование panic — для обычных ошибок используйте возврат ошибок
Отсутствие контекста — ошибка должна объяснять, что пошло не так и где

Что практиковать дальше:
Тестирование ошибок — написание тестов для различных сценариев ошибок
Метрики ошибок — сбор и анализ статистики по ошибкам
Грациозная деградация — продолжение работы при частичных сбоях
Распределенные системы — обработка ошибок в микросервисной архитектуре

Финальный проект:
Создайте приложение для управления задачами с полной обработкой ошибок:

Слои приложения:
API с HTTP обработкой ошибок
Бизнес-логика с пользовательскими ошибками
Хранилище с обертыванием ошибок БД

Типы ошибок:
Ошибки валидации
Ошибки бизнес-логики
Ошибки инфраструктуры

Обработка:
Повторные попытки для сетевых ошибок
Логирование с контекстом
Грациозная деградация

Тестирование:
Юнит-тесты для всех сценариев ошибок
Интеграционные тесты с эмуляцией сбоев

Совет: Начните с простой обработки ошибок и постепенно добавляйте более сложные техники. Практикуйтесь на реальных задачах — это лучший способ освоить обработку ошибок в Go.
Правильная обработка ошибок — это то, что отличает хорошие программы от отличных. Это требует дисциплины и практики, но результаты стоят того: надежные, предсказуемые и удобные в поддержке приложения.