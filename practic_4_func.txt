Практическое введение в функции с параметрами и возвращаемыми значениями в Go
Теоретическое введение
Цель урока: Научиться создавать функции с параметрами и возвращаемыми значениями, понимать различные способы передачи данных в функции и получения результатов.

Концепция: Функции — это основные строительные блоки программы. Они инкапсулируют логику, делают код переиспользуемым, читаемым и тестируемым. В Go функции являются первоклассными объектами — их можно передавать как аргументы, возвращать из других функций и присваивать переменным.

Зачем нужны функции:
Уменьшение дублирования кода
Разделение сложных задач на простые части
Повторное использование кода
Упрощение тестирования
Улучшение читаемости и поддерживаемости

Основные характеристики функций в Go:
Могут принимать ноль или более параметров
Могут возвращать ноль или более значений
Имеют явно указанные типы параметров и возвращаемых значений
Поддерживают множественные возвращаемые значения
Могут быть присвоены переменным (функции как значения)

Шаг 1: Базовые функции
Цель: Научиться создавать и вызывать простые функции с параметрами и возвращаемыми значениями.

Теория:
Функция объявляется с помощью ключевого слова func
Параметры указываются в скобках после имени функции
Тип возвращаемого значения указывается после списка параметров
Возврат значения осуществляется с помощью ключевого слова return

Практика:
go
package main

import (
    "fmt"
    "math"
    "strings"
)

// Функция без параметров и возвращаемого значения
func приветствие() {
    fmt.Println("Добро пожаловать в программу!")
    fmt.Println("------------------------------")
}

// Функция с одним параметром и без возвращаемого значения
func печатьИмени(имя string) {
    fmt.Printf("Привет, %s!\n", имя)
}

// Функция с одним параметром и одним возвращаемым значением
func квадрат(число int) int {
    return число * число
}

// Функция с двумя параметрами и одним возвращаемым значением
func сложить(a int, b int) int {
    return a + b
}

// Функция с параметрами одного типа (можно сократить)
func умножить(a, b int) int {
    return a * b
}

// Функция с разными типами параметров
func создатьEmail(имя, домен string) string {
    // Приводим имя к нижнему регистру и заменяем пробелы на точки
    имяФорма = strings.ToLower(strings.ReplaceAll(имя, " ", "."))
    return имяФорма + "@" + домен
}

// Функция с возвратом логического значения
func четноеЛи(число int) bool {
    return число%2 == 0
}

// Функция для расчета площади круга
func площадьКруга(радиус float64) float64 {
    return math.Pi * радиус * радиус
}

// Функция для расчета периметра прямоугольника
func периметрПрямоугольника(ширина, высота float64) float64 {
    return 2 * (ширина + высота)
}

func main() {
    fmt.Println("=== Базовые функции ===")
    
    // Вызов функции без параметров
    приветствие()
    
    // Вызов функции с одним параметром
    печатьИмени("Анна")
    печатьИмени("Борис")
    
    // Вызов функции с возвращаемым значением
    результат := квадрат(5)
    fmt.Printf("Квадрат числа 5: %d\n", результат)
    
    // Можно использовать результат сразу
    fmt.Printf("Квадрат числа 3: %d\n", квадрат(3))
    
    // Функции с несколькими параметрами
    сумма := сложить(10, 20)
    fmt.Printf("Сумма 10 и 20: %d\n", сумма)
    
    произведение := умножить(7, 8)
    fmt.Printf("Произведение 7 и 8: %d\n", произведение)
    
    // Практические примеры
    email := создатьEmail("Иван Иванов", "example.com")
    fmt.Printf("Email для Ивана Иванова: %s\n", email)
    
    email = создатьEmail("Мария Петрова", "company.ru")
    fmt.Printf("Email для Марии Петровой: %s\n", email)
    
    // Проверка на четность
    число := 42
    if четноеЛи(число) {
        fmt.Printf("Число %d - четное\n", число)
    } else {
        fmt.Printf("Число %d - нечетное\n", число)
    }
    
    // Геометрические расчеты
    радиус := 5.0
    площадь := площадьКруга(радиус)
    fmt.Printf("Площадь круга с радиусом %.1f: %.2f\n", радиус, площадь)
    
    ширина := 4.0
    высота := 3.0
    периметр := периметрПрямоугольника(ширина, высота)
    fmt.Printf("Периметр прямоугольника %.1fx%.1f: %.1f\n", ширина, высота, периметр)
    
    // Композиция функций (использование результата одной функции как аргумент другой)
    fmt.Println("\n=== Композиция функций ===")
    
    // Вычисляем квадрат суммы
    квадратСуммы := квадрат(сложить(3, 4))
    fmt.Printf("Квадрат суммы 3 и 4: %d\n", квадратСуммы)
    
    // Проверяем, четная ли сумма двух чисел
    суммаЧисел := сложить(15, 7)
    четная := четноеЛи(суммаЧисел)
    fmt.Printf("Сумма 15 и 7 (%d) четная? %v\n", суммаЧисел, четная)
    
    // Вложенные вызовы функций
    fmt.Printf("Площадь круга с радиусом 2 (округлено): %.0f\n", math.Round(площадьКруга(2)))
    
    // Функции как выражения
    fmt.Println("\n=== Функции в выражениях ===")
    
    // Использование функций в условных выражениях
    if четноеЛи(умножить(5, 7)) {
        fmt.Println("Произведение 5 и 7 - четное число")
    } else {
        fmt.Println("Произведение 5 и 7 - нечетное число")
    }
    
    // Использование в цикле
    fmt.Println("Квадраты чисел от 1 до 5:")
    for i := 1; i <= 5; i++ {
        fmt.Printf("%d^2 = %d\n", i, квадрат(i))
    }
}
Объяснение:
func приветствие() — функция без параметров и возвращаемого значения.
func печатьИмени(имя string) — функция с одним параметром типа string.
func квадрат(число int) int — функция с одним параметром и одним возвращаемым значением.
func сложить(a int, b int) int — функция с двумя параметрами.
func умножить(a, b int) int — сокращенная запись параметров одного типа.
return — ключевое слово для возврата значения.

Композиция функций — использование результата одной функции как аргумента другой.
Функции в выражениях — функции можно использовать в любых выражениях, где ожидается значение.
Задание для самостоятельной работы 1:
Создайте функцию максимум(a, b int) int, которая возвращает большее из двух чисел
Создайте функцию факториал(n int) int, которая вычисляет факториал числа
Создайте функцию конвертироватьВФаренгейт(цельсий float64) float64 для конвертации температуры
Создайте функцию форматироватьВремя(секунды int) string, которая форматирует время в формате "ЧЧ:MM:СС"

Протестируйте все функции

Шаг 2: Множественные возвращаемые значения
Цель: Научиться создавать функции, которые возвращают несколько значений.

Теория:
Go позволяет функциям возвращать несколько значений
Возвращаемые значения указываются в скобках
Для получения значений используется множественное присваивание
Одно из частых применений — возврат результата и ошибки

Практика:
go
package main

import (
    "fmt"
    "math"
)

// Функция, возвращающая два значения: результат и остаток от деления
func делить(делимое, делитель int) (int, int) {
    частное := делимое / делитель
    остаток := делимое % делитель
    return частное, остаток
}

// Функция, возвращающая три значения: минимум, максимум и среднее
func статистика(числа ...int) (int, int, float64) {
    if len(числа) == 0 {
        return 0, 0, 0
    }
    
    минимум := числа[0]
    максимум := числа[0]
    сумма := 0
    
    for _, число := range числа {
        if число < минимум {
            минимум = число
        }
        if число > максимум {
            максимум = число
        }
        сумма += число
    }
    
    среднее := float64(сумма) / float64(len(числа))
    return минимум, максимум, среднее
}

// Функция для решения квадратного уравнения: ax² + bx + c = 0
// Возвращает два корня и флаг, указывающий, есть ли действительные корни
func решитьКвадратноеУравнение(a, b, c float64) (float64, float64, bool) {
    дискриминант := b*b - 4*a*c
    
    // Если дискриминант отрицательный, корней нет
    if дискриминант < 0 {
        return 0, 0, false
    }
    
    кореньД := math.Sqrt(дискриминант)
    корень1 := (-b + кореньД) / (2 * a)
    корень2 := (-b - кореньД) / (2 * a)
    
    return корень1, корень2, true
}

// Функция для разбора полного имени на имя и фамилию
func разобратьИмя(полноеИмя string) (имя, фамилия string) {
    части := strings.Split(полноеИмя, " ")
    
    if len(части) >= 2 {
        имя = части[0]
        фамилия = части[len(части)-1] // Берем последнюю часть как фамилию
    } else if len(части) == 1 {
        имя = части[0]
        фамилия = ""
    }
    
    return имя, фамилия
}

// Функция для безопасного деления с проверкой деления на ноль
func безопасноеДеление(делимое, делитель float64) (результат float64, ошибка bool) {
    if делитель == 0 {
        return 0, true // true означает ошибку
    }
    
    результат = делимое / делитель
    return результат, false // false означает нет ошибки
}

// Функция для конвертации секунд в часы, минуты и секунды
func разобратьВремя(секундыВсего int) (часы, минуты, секунды int) {
    часы = секундыВсего / 3600
    остаток := секундыВсего % 3600
    минуты = остаток / 60
    секунды = остаток % 60
    
    return часы, минуты, секунды
}

func main() {
    fmt.Println("=== Множественные возвращаемые значения ===")
    
    // Деление с остатком
    частное, остаток := делить(17, 5)
    fmt.Printf("17 / 5 = %d (остаток %d)\n", частное, остаток)
    
    // Если нужно только одно значение, используем пустой идентификатор _
    частное, _ = делить(20, 3)
    fmt.Printf("20 / 3 = %d (остаток игнорируем)\n", частное)
    
    // Статистика по набору чисел
    мин, макс, ср := статистика(12, 8, 15, 3, 20, 7)
    fmt.Printf("Статистика: мин=%d, макс=%d, среднее=%.2f\n", мин, макс, ср)
    
    // Решение квадратного уравнения
    fmt.Println("\n=== Решение квадратных уравнений ===")
    
    // x² - 5x + 6 = 0, корни: 2 и 3
    корень1, корень2, естьКорни := решитьКвадратноеУравнение(1, -5, 6)
    if естьКорни {
        fmt.Printf("Уравнение x² - 5x + 6 = 0 имеет корни: %.1f и %.1f\n", корень1, корень2)
    } else {
        fmt.Println("Действительных корней нет")
    }
    
    // x² + 1 = 0, корней нет
    корень1, корень2, естьКорни = решитьКвадратноеУравнение(1, 0, 1)
    if естьКорни {
        fmt.Printf("Уравнение x² + 1 = 0 имеет корни: %.1f и %.1f\n", корень1, корень2)
    } else {
        fmt.Println("Уравнение x² + 1 = 0 не имеет действительных корней")
    }
    
    // Разбор имени
    fmt.Println("\n=== Работа с именами ===")
    имя, фамилия := разобратьИмя("Иван Петров")
    fmt.Printf("Полное имя: Иван Петров\nИмя: %s\nФамилия: %s\n", имя, фамилия)
    
    имя, фамилия = разобратьИмя("Мария")
    fmt.Printf("Полное имя: Мария\nИмя: %s\nФамилия: %s\n", имя, фамилия)
    
    имя, фамилия = разобратьИмя("Анна Мария Иванова")
    fmt.Printf("Полное имя: Анна Мария Иванова\nИмя: %s\nФамилия: %s\n", имя, фамилия)
    
    // Безопасное деление
    fmt.Println("\n=== Безопасное деление ===")
    
    результат, ошибка := безопасноеДеление(10, 2)
    if ошибка {
        fmt.Println("Ошибка: деление на ноль!")
    } else {
        fmt.Printf("10 / 2 = %.1f\n", результат)
    }
    
    результат, ошибка = безопасноеДеление(10, 0)
    if ошибка {
        fmt.Println("Ошибка: деление на ноль!")
    } else {
        fmt.Printf("10 / 0 = %.1f\n", результат)
    }
    
    // Разбор времени
    fmt.Println("\n=== Конвертация времени ===")
    
    часы, минуты, секунды := разобратьВремя(3665)
    fmt.Printf("3665 секунд = %d часов, %d минут, %d секунд\n", часы, минуты, секунды)
    
    часы, минуты, секунды = разобратьВремя(12345)
    fmt.Printf("12345 секунд = %d часов, %d минут, %d секунд\n", часы, минуты, секунды)
    
    // Практический пример: калькулятор с обработкой ошибок
    fmt.Println("\n=== Калькулятор с обработкой ошибок ===")
    
    калькулятор := func(операция string, a, b float64) (результат float64, успех bool) {
        switch операция {
        case "+":
            return a + b, true
        case "-":
            return a - b, true
        case "*":
            return a * b, true
        case "/":
            if b == 0 {
                return 0, false
            }
            return a / b, true
        default:
            return 0, false
        }
    }
    
    операции := []struct{
        операция string
        a, b float64
    }{
        {"+", 10, 5},
        {"-", 10, 5},
        {"*", 10, 5},
        {"/", 10, 5},
        {"/", 10, 0},
        {"%", 10, 5},
    }
    
    for _, оп := range операции {
        результат, успех := калькулятор(оп.операция, оп.a, оп.b)
        if успех {
            fmt.Printf("%.1f %s %.1f = %.1f\n", оп.a, оп.операция, оп.b, результат)
        } else {
            fmt.Printf("Ошибка в операции: %.1f %s %.1f\n", оп.a, оп.операция, оп.b)
        }
    }
}
Объяснение:
Множественные возвращаемые значения — указываются в скобках: (int, int).
Множественное присваивание — частное, остаток := делить(17, 5).
Пустой идентификатор _ — используется, когда значение не нужно.
Возврат результата и ошибки — распространенный паттерн в Go.
Именованные возвращаемые значения — можно задать имена возвращаемым значениям (см. следующий раздел).

Задание для самостоятельной работы 2:
Создайте функцию разложитьНаПростыеМножители(n int) []int, которая возвращает простые множители числа
Создайте функцию анализироватьТекст(текст string) (слов int, символов int, строк int) для анализа текста
Создайте функцию конвертироватьВалюту(сумма float64, курс float64) (результат float64, ошибка error)
Создайте функцию найтиКорниЛинейногоУравнения(a, b float64) (корень float64, естьРешение bool)

Шаг 3: Именованные возвращаемые значения
Цель: Научиться использовать именованные возвращаемые значения для улучшения читаемости кода.

Теория:
Возвращаемым значениям можно дать имена в сигнатуре функции
Именованные значения автоматически инициализируются нулевыми значениями
Можно использовать return без указания значений (naked return)
Улучшает читаемость, особенно когда возвращаемых значений много

Практика:
go
package main

import (
    "fmt"
    "math"
    "strings"
)

// Функция с именованными возвращаемыми значениями
func рассчитатьСтатистику(числа []int) (минимум, максимум, сумма, среднее int) {
    // Проверяем пустой срез
    if len(числа) == 0 {
        return // naked return - вернет нулевые значения всех именованных возвращаемых значений
    }
    
    // Инициализируем значения
    минимум = числа[0]
    максимум = числа[0]
    сумма = 0
    
    // Вычисляем статистику
    for _, число := range числа {
        if число < минимум {
            минимум = число
        }
        if число > максимум {
            максимум = число
        }
        сумма += число
    }
    
    среднее = сумма / len(числа)
    return // naked return
}

// Функция для разбора URL на компоненты
func разобратьURL(url string) (протокол, домен, путь string, порт int) {
    // Значения по умолчанию
    протокол = "http"
    порт = 80
    
    // Разбираем протокол
    if strings.HasPrefix(url, "https://") {
        протокол = "https"
        порт = 443
        url = strings.TrimPrefix(url, "https://")
    } else if strings.HasPrefix(url, "http://") {
        url = strings.TrimPrefix(url, "http://")
    }
    
    // Находим домен и путь
    parts := strings.SplitN(url, "/", 2)
    домен = parts[0]
    
    // Проверяем порт в домене
    if strings.Contains(домен, ":") {
        domainParts := strings.Split(домен, ":")
        домен = domainParts[0]
        // В реальном коде нужно преобразовывать строку в int и обрабатывать ошибки
        // Для простоты игнорируем порт в этом примере
    }
    
    if len(parts) > 1 {
        путь = "/" + parts[1]
    } else {
        путь = "/"
    }
    
    return // naked return
}

// Функция для расчета характеристик прямоугольника
func характеристикиПрямоугольника(ширина, высота float64) (площадь, периметр, диагональ float64) {
    площадь = ширина * высота
    периметр = 2 * (ширина + высота)
    диагональ = math.Sqrt(ширина*ширина + высота*высота)
    return // naked return
}

// Функция для конвертации градусов в радианы и наоборот
func конвертироватьУглы(градусы float64) (радианы, грады float64) {
    радианы = градусы * math.Pi / 180
    грады = градусы * 200 / 180 // 200 градов в 180 градусах
    return // naked return
}

// Функция для обработки пользовательских данных с обработкой ошибок
func обработатьПользовательскиеДанные(имя, email string) (форматированноеИмя, форматированныйEmail string, ошибка error) {
    // Проверяем имя
    имя = strings.TrimSpace(имя)
    if len(имя) == 0 {
        ошибка = fmt.Errorf("имя не может быть пустым")
        return // вернет пустые строки и ошибку
    }
    
    // Проверяем email
    email = strings.TrimSpace(email)
    if len(email) == 0 {
        ошибка = fmt.Errorf("email не может быть пустым")
        return
    }
    
    if !strings.Contains(email, "@") {
        ошибка = fmt.Errorf("неправильный формат email")
        return
    }
    
    // Форматируем данные
    форматированноеИмя = strings.Title(strings.ToLower(имя))
    форматированныйEmail = strings.ToLower(email)
    
    return // naked return
}

func main() {
    fmt.Println("=== Именованные возвращаемые значения ===")
    
    // Статистика
    числа := []int{12, 8, 15, 3, 20, 7}
    мин, макс, сумма, ср := рассчитатьСтатистику(числа)
    fmt.Printf("Числа: %v\n", числа)
    fmt.Printf("Статистика: мин=%d, макс=%d, сумма=%d, среднее=%d\n", мин, макс, сумма, ср)
    
    // Работа с URL
    fmt.Println("\n=== Разбор URL ===")
    
    url := "https://example.com/path/to/resource"
    протокол, домен, путь, порт := разобратьURL(url)
    fmt.Printf("URL: %s\n", url)
    fmt.Printf("Протокол: %s\nДомен: %s\nПуть: %s\nПорт: %d\n", протокол, домен, путь, порт)
    
    url = "http://localhost:8080/api/users"
    протокол, домен, путь, порт = разобратьURL(url)
    fmt.Printf("\nURL: %s\n", url)
    fmt.Printf("Протокол: %s\nДомен: %s\nПуть: %s\nПорт: %d\n", протокол, домен, путь, порт)
    
    // Характеристики прямоугольника
    fmt.Println("\n=== Характеристики прямоугольника ===")
    
    ширина := 3.0
    высота := 4.0
    площадь, периметр, диагональ := характеристикиПрямоугольника(ширина, высота)
    fmt.Printf("Прямоугольник %.1fx%.1f:\n", ширина, высота)
    fmt.Printf("Площадь: %.1f\nПериметр: %.1f\nДиагональ: %.1f\n", площадь, периметр, диагональ)
    
    // Конвертация углов
    fmt.Println("\n=== Конвертация углов ===")
    
    градусы := 90.0
    радианы, грады := конвертироватьУглы(градусы)
    fmt.Printf("%.0f градусов = %.2f радиан = %.0f градов\n", градусы, радианы, грады)
    
    градусы = 180.0
    радианы, грады = конвертироватьУглы(градусы)
    fmt.Printf("%.0f градусов = %.2f радиан = %.0f градов\n", градусы, радианы, грады)
    
    // Обработка пользовательских данных с ошибками
    fmt.Println("\n=== Обработка пользовательских данных ===")
    
    тестовыеДанные := []struct {
        имя   string
        email string
    }{
        {"Иван Иванов", "ivan@example.com"},
        {"  ", "ivan@example.com"}, // Пустое имя
        {"Мария", ""},               // Пустой email
        {"Петр", "петр.example.com"}, // Неправильный email
        {"АННА", "ANNA@EXAMPLE.COM"}, // Верхний регистр
    }
    
    for _, данные := range тестовыеДанные {
        имя, email, err := обработатьПользовательскиеДанные(данные.имя, данные.email)
        
        if err != nil {
            fmt.Printf("Ошибка для %s, %s: %v\n", данные.имя, данные.email, err)
        } else {
            fmt.Printf("Успех: имя='%s', email='%s'\n", имя, email)
        }
    }
    
    // Преимущества именованных возвращаемых значений
    fmt.Println("\n=== Преимущества именованных возвращаемых значений ===")
    
    // 1. Улучшенная документация функции
    // 2. Легче понять, что возвращает функция
    // 3. Упрощает рефакторинг при изменении возвращаемых значений
    // 4. Полезно при множественных return в разных местах функции
    
    // Пример функции, где return в разных местах
    функцияСНесколькимиReturn := func(число int) (квадрат, куб int) {
        if число == 0 {
            return // вернет 0, 0
        }
        
        квадрат = число * число
        
        if число < 0 {
            return // вернет квадрат и 0 для куба
        }
        
        куб = число * число * число
        return // вернет и квадрат, и куб
    }
    
    квадрат, куб := функцияСНесколькимиReturn(3)
    fmt.Printf("Для числа 3: квадрат=%d, куб=%d\n", квадрат, куб)
    
    квадрат, куб = функцияСНесколькимиReturn(-2)
    fmt.Printf("Для числа -2: квадрат=%d, куб=%d\n", квадрат, куб)
    
    квадрат, куб = функцияСНесколькимиReturn(0)
    fmt.Printf("Для числа 0: квадрат=%d, куб=%d\n", квадрат, куб)
}
Объяснение:
Именованные возвращаемые значения — (минимум, максимум, сумма, среднее int).
Naked return — return без указания значений возвращает текущие значения именованных переменных.
Автоматическая инициализация — именованные возвращаемые значения инициализируются нулевыми значениями.
Улучшение читаемости — имена помогают понять, что возвращает функция.
Осторожность с naked return — в больших функциях может ухудшить читаемость.

Задание для самостоятельной работы 3:
Создайте функцию анализироватьФайл(путь string) (размер int64, являетсяКаталогом bool, существует bool, ошибка error) для анализа файла
Создайте функцию рассчитатьКредит(сумма float64, срокМесяцев int, ставкаГодовая float64) (ежемесячныйПлатеж, общаяСумма, переплата float64)
Создайте функцию разобратьДату(датаСтрока string) (год, месяц, день int, ошибка error) для разбора даты

Шаг 4: Функции как значения (функциональный тип)
Цель: Научиться использовать функции как значения: присваивать переменным, передавать как аргументы, возвращать из других функций.

Теория:
В Go функции являются первоклассными объектами
Функции можно присваивать переменным
Функции можно передавать как аргументы другим функциям
Функции можно возвращать из других функций
Можно определять типы функций для улучшения читаемости

Практика:
go
package main

import (
    "fmt"
    "strings"
)

// Определение типа функции
type МатематическаяОперация func(float64, float64) float64
type Фильтр func(string) bool
type Преобразователь func(string) string

// Функция, принимающая другую функцию как аргумент
func применитьОперацию(a, b float64, операция МатематическаяОперация) float64 {
    return операция(a, b)
}

// Функция, возвращающая функцию
func создатьМножитель(коэффициент float64) МатематическаяОперация {
    return func(a, b float64) float64 {
        return a * b * коэффициент
    }
}

// Функция для фильтрации среза строк
func фильтроватьСтроки(строки []string, фильтр Фильтр) []string {
    результат := []string{}
    
    for _, строка := range строки {
        if фильтр(строка) {
            результат = append(результат, строка)
        }
    }
    
    return результат
}

// Функция для преобразования всех строк в срезе
func преобразоватьСтроки(строки []string, преобразователь Преобразователь) []string {
    результат := make([]string, len(строки))
    
    for i, строка := range строки {
        результат[i] = преобразователь(строка)
    }
    
    return результат
}

// Функция высшего порядка: применяет функцию к каждому элементу
func применитьККаждому(числа []int, функция func(int) int) []int {
    результат := make([]int, len(числа))
    
    for i, число := range числа {
        результат[i] = функция(число)
    }
    
    return результат
}

func main() {
    fmt.Println("=== Функции как значения ===")
    
    // Присваивание функции переменной
    fmt.Println("\n=== Присваивание функций переменным ===")
    
    сложение := func(a, b float64) float64 {
        return a + b
    }
    
    вычитание := func(a, b float64) float64 {
        return a - b
    }
    
    умножение := func(a, b float64) float64 {
        return a * b
    }
    
    деление := func(a, b float64) float64 {
        if b != 0 {
            return a / b
        }
        return 0
    }
    
    // Использование функций из переменных
    a, b := 10.0, 3.0
    fmt.Printf("%.1f + %.1f = %.1f\n", a, b, сложение(a, b))
    fmt.Printf("%.1f - %.1f = %.1f\n", a, b, вычитание(a, b))
    fmt.Printf("%.1f * %.1f = %.1f\n", a, b, умножение(a, b))
    fmt.Printf("%.1f / %.1f = %.1f\n", a, b, деление(a, b))
    
    // Передача функции как аргумента
    fmt.Println("\n=== Передача функций как аргументов ===")
    
    результат := применитьОперацию(5, 3, сложение)
    fmt.Printf("применитьОперацию(5, 3, сложение) = %.1f\n", результат)
    
    результат = применитьОперацию(5, 3, умножение)
    fmt.Printf("применитьОперацию(5, 3, умножение) = %.1f\n", результат)
    
    // Использование определенного типа функции
    операция := сложение
    результат = применитьОперацию(7, 2, операция)
    fmt.Printf("применитьОперацию(7, 2, операция) = %.1f\n", результат)
    
    // Функция, возвращающая функцию
    fmt.Println("\n=== Функции, возвращающие функции ===")
    
    умножитьНаДва := создатьМножитель(2.0)
    умножитьНаТри := создатьМножитель(3.0)
    
    fmt.Printf("умножитьНаДва(3, 4) = %.1f\n", умножитьНаДва(3, 4))
    fmt.Printf("умножитьНаТри(3, 4) = %.1f\n", умножитьНаТри(3, 4))
    
    // Фильтрация строк
    fmt.Println("\n=== Фильтрация и преобразование строк ===")
    
    строки := []string{"яблоко", "апельсин", "банан", "арбуз", "вишня", "ананас"}
    
    // Фильтр: строки, начинающиеся на 'а'
    начинаетсяНаА := func(s string) bool {
        return strings.HasPrefix(s, "а")
    }
    
    // Фильтр: строки длиной более 5 символов
    длиннееПяти := func(s string) bool {
        return len(s) > 5
    }
    
    отфильтрованныенаА := фильтроватьСтроки(строки, начинаетсяНаА)
    fmt.Printf("Строки, начинающиеся на 'а': %v\n", отфильтрованныенаА)
    
    отфильтрованныеДлинные := фильтроватьСтроки(строки, длиннееПяти)
    fmt.Printf("Строки длиннее 5 символов: %v\n", отфильтрованныеДлинные)
    
    // Преобразование строк
    вВерхнийРегистр := func(s string) string {
        return strings.ToUpper(s)
    }
    
    вНижнийРегистр := func(s string) string {
        return strings.ToLower(s)
    }
    
    сЗаглавнойБуквы := func(s string) string {
        if len(s) > 0 {
            return strings.ToUpper(s[:1]) + s[1:]
        }
        return s
    }
    
    преобразованныеВерхний := преобразоватьСтроки(строки, вВерхнийРегистр)
    fmt.Printf("В верхнем регистре: %v\n", преобразованныеВерхний)
    
    преобразованныеСЗаглавной := преобразоватьСтроки(строки, сЗаглавнойБуквы)
    fmt.Printf("С заглавной буквы: %v\n", преобразованныеСЗаглавной)
    
    // Применение функции к каждому элементу
    fmt.Println("\n=== Применение функции к каждому элементу ===")
    
    числа := []int{1, 2, 3, 4, 5}
    
    квадрат := func(x int) int {
        return x * x
    }
    
    удвоить := func(x int) int {
        return x * 2
    }
    
    инкремент := func(x int) int {
        return x + 1
    }
    
    квадраты := применитьККаждому(числа, квадрат)
    fmt.Printf("Квадраты %v: %v\n", числа, квадраты)
    
    удвоенные := применитьККаждому(числа, удвоить)
    fmt.Printf("Удвоенные %v: %v\n", числа, удвоенные)
    
    инкрементированные := применитьККаждому(числа, инкремент)
    fmt.Printf("Инкрементированные %v: %v\n", числа, инкрементированные)
    
    // Композиция функций
    fmt.Println("\n=== Композиция функций ===")
    
    // Функция, которая комбинирует две другие функции
    композиция := func(f, g func(int) int) func(int) int {
        return func(x int) int {
            return f(g(x))
        }
    }
    
    квадратПлюсОдин := композиция(инкремент, квадрат)
    результатКомпозиции := применитьККаждому(числа, квадратПлюсОдин)
    fmt.Printf("Квадрат + 1 для %v: %v\n", числа, результатКомпозиции)
    
    // Практический пример: калькулятор с операциями
    fmt.Println("\n=== Калькулятор с динамическими операциями ===")
    
    операцииКалькулятора := map[string]МатематическаяОперация{
        "+": сложение,
        "-": вычитание,
        "*": умножение,
        "/": деление,
    }
    
    тестовыеОперации := []struct {
        a, b float64
        op   string
    }{
        {10, 5, "+"},
        {10, 5, "-"},
        {10, 5, "*"},
        {10, 5, "/"},
        {10, 0, "/"},
    }
    
    for _, тест := range тестовыеОперации {
        операция, найдено := операцииКалькулятора[тест.op]
        if найдено {
            результат := операция(тест.a, тест.b)
            fmt.Printf("%.1f %s %.1f = %.1f\n", тест.a, тест.op, тест.b, результат)
        } else {
            fmt.Printf("Неизвестная операция: %s\n", тест.op)
        }
    }
}
Объяснение:
Типы функций — type МатематическаяОперация func(float64, float64) float64.
Функции как значения — можно присваивать переменным, передавать как аргументы.
Функции высшего порядка — функции, которые принимают или возвращают другие функции.
Анонимные функции — функции без имени, определяемые на месте.
Замыкания — функции, захватывающие переменные из окружающего контекста (см. следующий раздел).
Композиция функций — создание новых функций из существующих.

Задание для самостоятельной работы 4:
Создайте тип Сортировщик func([]int) []int и несколько реализаций (пузырьковая, быстрая, выбором)
Создайте функцию создатьФильтр(минимальнаяДлина, максимальнаяДлина int) Фильтр для фильтрации строк по длине
Создайте функцию применитьЦепочкуПреобразований(строка string, преобразования ...Преобразователь) string для последовательного применения преобразований
Реализуйте функцию мемоизация(f func(int) int) func(int) int, которая кэширует результаты вычислений

Шаг 5: Замыкания (closures)
Цель: Понять и научиться использовать замыкания — функции, которые захватывают переменные из окружающего контекста.

Теория:
Замыкание — это функция, которая запоминает переменные из окружающей области видимости
Замыкания могут изменять захваченные переменные
Полезны для создания функций с состоянием
Часто используются для callback'ов, генераторов, мемоизации

Практика:
go
package main

import (
    "fmt"
    "strings"
)

// Функция, возвращающая замыкание для счетчика
func создатьСчетчик(начальноеЗначение int) func() int {
    счетчик := начальноеЗначение
    
    // Возвращаемая функция - замыкание, захватывает переменную счетчик
    return func() int {
        счетчик++
        return счетчик
    }
}

// Функция для создания генератора чисел
func создатьГенератор(начало, шаг int) func() int {
    текущее := начало - шаг
    
    return func() int {
        текущее += шаг
        return текущее
    }
}

// Замыкание для создания префиксного сумматора
func создатьСумматор() func(int) int {
    сумма := 0
    
    return func(число int) int {
        сумма += число
        return сумма
    }
}

// Замыкание для создания функции-фильтра с настраиваемыми условиями
func создатьФильтрСтрок(условия ...func(string) bool) func(string) bool {
    return func(строка string) bool {
        for _, условие := range условия {
            if !условие(строка) {
                return false
            }
        }
        return true
    }
}

// Замыкание для кэширования результатов функции (мемоизация)
func мемоизировать(f func(int) int) func(int) int {
    кэш := make(map[int]int)
    
    return func(n int) int {
        // Проверяем, есть ли результат в кэше
        if результат, найдено := кэш[n]; найдено {
            fmt.Printf("Результат для %d взят из кэша\n", n)
            return результат
        }
        
        // Вычисляем и сохраняем в кэш
        результат := f(n)
        кэш[n] = результат
        fmt.Printf("Результат для %d вычислен и сохранен в кэш\n", n)
        return результат
    }
}

// Замыкание для создания логгера с уровнем логирования
func создатьЛоггер(уровень string) func(string) {
    return func(сообщение string) {
        fmt.Printf("[%s] %s\n", уровень, сообщение)
    }
}

func main() {
    fmt.Println("=== Замыкания (closures) ===")
    
    // Счетчики
    fmt.Println("\n=== Счетчики ===")
    
    счетчик1 := создатьСчетчик(0)
    счетчик2 := создатьСчетчик(100)
    
    fmt.Println("Счетчик 1:")
    for i := 0; i < 3; i++ {
        fmt.Printf("  Вызов %d: %d\n", i+1, счетчик1())
    }
    
    fmt.Println("Счетчик 2 (начинается с 100):")
    for i := 0; i < 3; i++ {
        fmt.Printf("  Вызов %d: %d\n", i+1, счетчик2())
    }
    
    // Каждое замыкание имеет свое собственное состояние
    fmt.Println("Счетчик 1 снова:")
    fmt.Printf("  Следующее значение: %d\n", счетчик1())
    
    // Генераторы
    fmt.Println("\n=== Генераторы чисел ===")
    
    четныеЧисла := создатьГенератор(0, 2)
    степениДвойки := создатьГенератор(1, 2) // Умножаем на 2 каждый раз
    
    fmt.Println("Первые 5 четных чисел:")
    for i := 0; i < 5; i++ {
        fmt.Printf("  %d\n", четныеЧисла())
    }
    
    fmt.Println("Первые 5 степеней двойки:")
    for i := 0; i < 5; i++ {
        fmt.Printf("  %d\n", степениДвойки())
    }
    
    // Сумматор
    fmt.Println("\n=== Сумматор ===")
    
    сумматор := создатьСумматор()
    
    чисел := []int{1, 2, 3, 4, 5}
    for _, число := range чисел {
        текущаяСумма := сумматор(число)
        fmt.Printf("Добавили %d, текущая сумма: %d\n", число, текущаяСумма)
    }
    
    // Создаем новый сумматор (с нуля)
    новыйСумматор := создатьСумматор()
    fmt.Printf("Новый сумматор, добавляем 10: %d\n", новыйСумматор(10))
    fmt.Printf("Добавляем 20: %d\n", новыйСумматор(20))
    
    // Фильтры с замыканиями
    fmt.Println("\n=== Составные фильтры ===")
    
    строки := []string{"яблоко", "апельсин", "банан", "арбуз", "вишня", "ананас", "абрикос"}
    
    // Создаем условия
    начинаетсяНаА := func(s string) bool { return strings.HasPrefix(s, "а") }
    длиннее4 := func(s string) bool { return len(s) > 4 }
    содержитН := func(s string) bool { return strings.Contains(s, "н") }
    
    // Создаем составной фильтр
    фильтр := создатьФильтрСтрок(начинаетсяНаА, длиннее4, содержитН)
    
    fmt.Println("Строки, которые начинаются на 'а', длиннее 4 символов и содержат 'н':")
    for _, строка := range строки {
        if фильтр(строка) {
            fmt.Printf("  %s\n", строка)
        }
    }
    
    // Мемоизация (кэширование)
    fmt.Println("\n=== Мемоизация (кэширование результатов) ===")
    
    // Медленная функция (имитация)
    медленнаяФункция := func(n int) int {
        // Имитация сложных вычислений
        результат := 0
        for i := 0; i < 100000000; i++ {
            результат = n * n // Просто чтобы занять время
        }
        return n * n
    }
    
    мемоизированная := мемоизировать(медленнаяФункция)
    
    // Первый вызов - вычисляется
    fmt.Println("Первый вызов для 5:")
    результат1 := мемоизированная(5)
    fmt.Printf("  Результат: %d\n", результат1)
    
    // Второй вызов - берется из кэша
    fmt.Println("\nВторой вызов для 5:")
    результат2 := мемоизированная(5)
    fmt.Printf("  Результат: %d\n", результат2)
    
    // Вызов для другого числа - вычисляется
    fmt.Println("\nПервый вызов для 10:")
    результат3 := мемоизированная(10)
    fmt.Printf("  Результат: %d\n", результат3)
    
    // Еще раз для 5 - из кэша
    fmt.Println("\nТретий вызов для 5:")
    результат4 := мемоизированная(5)
    fmt.Printf("  Результат: %d\n", результат4)
    
    // Логгеры с разными уровнями
    fmt.Println("\n=== Логгеры с замыканиями ===")
    
    логгерИнфо := создатьЛоггер("INFO")
    логгерОшибка := создатьЛоггер("ERROR")
    логгерОтладка := создатьЛоггер("DEBUG")
    
    логгерИнфо("Приложение запущено")
    логгерОтладка("Загружена конфигурация")
    логгерИнфо("Пользователь вошел в систему")
    логгерОшибка("Ошибка подключения к базе данных")
    логгерИнфо("Приложение завершено")
    
    // Практический пример: банкомат
    fmt.Println("\n=== Практический пример: банкомат ===")
    
    создатьБанкомат := func(начальныйБаланс float64) func(float64) (float64, bool) {
        баланс := начальныйБаланс
        
        return func(сумма float64) (float64, bool) {
            if сумма <= 0 {
                return баланс, false // Нельзя снять отрицательную сумму или ноль
            }
            
            if сумма > баланс {
                return баланс, false // Недостаточно средств
            }
            
            баланс -= сумма
            return баланс, true
        }
    }
    
    банкомат := создатьБанкомат(1000.0) // Начальный баланс 1000
    
    операции := []float64{100, 200, 500, 300, 100}
    
    for _, сумма := range операции {
        новыйБаланс, успех := банкомат(сумма)
        if успех {
            fmt.Printf("Снято %.2f, новый баланс: %.2f\n", сумма, новыйБаланс)
        } else {
            fmt.Printf("Не удалось снять %.2f, текущий баланс: %.2f\n", сумма, новыйБаланс)
        }
    }
}
Объяснение:
Захват переменных — замыкание запоминает переменные из окружающей области видимости.
Независимые состояния — каждое замыкание имеет собственное состояние.
Изменение захваченных переменных — замыкания могут изменять захваченные переменные.
Практическое применение — генераторы, счетчики, мемоизация, логгеры, конечные автоматы.
Эффективность — замыкания могут быть более эффективными, чем объекты в некоторых случаях.

Задание для самостоятельной работы 5:
Создайте замыкание создатьИсториюОпераций() func(string) []string, которое хранит историю операций
Создайте замыкание создатьТаймер() func() int, которое возвращает время с момента создания
Реализуйте замыкание для rate limiting (ограничение частоты вызовов)
Создайте замыкание для валидации данных с настраиваемыми правилами

Шаг 6: Рекурсивные функции
Цель: Научиться создавать рекурсивные функции — функции, которые вызывают сами себя.

Теория:
Рекурсия — это когда функция вызывает саму себя
Должно быть условие выхода (базовый случай), иначе бесконечная рекурсия
Полезны для задач, которые можно разбить на подзадачи той же природы
Могут быть менее эффективны, чем итеративные решения
Часто используются для обхода деревьев, математических последовательностей

Практика:
go
package main

import "fmt"

// Рекурсивное вычисление факториала
func факториал(n int) int {
    // Базовый случай: факториал 0 и 1 равен 1
    if n <= 1 {
        return 1
    }
    
    // Рекурсивный случай: n! = n * (n-1)!
    return n * факториал(n-1)
}

// Рекурсивное вычисление чисел Фибоначчи
func фибоначчи(n int) int {
    // Базовые случаи
    if n <= 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    
    // Рекурсивный случай: F(n) = F(n-1) + F(n-2)
    return фибоначчи(n-1) + фибоначчи(n-2)
}

// Рекурсивное вычисление суммы чисел от 1 до n
func суммаДо(n int) int {
    if n <= 0 {
        return 0
    }
    
    return n + суммаДо(n-1)
}

// Рекурсивное возведение в степень
func степень(основание float64, показатель int) float64 {
    if показатель == 0 {
        return 1
    }
    
    if показатель < 0 {
        return 1 / степень(основание, -показатель)
    }
    
    return основание * степень(основание, показатель-1)
}

// Рекурсивный бинарный поиск
func бинарныйПоиск(массив []int, цель, лево, право int) int {
    // Базовый случай: элемент не найден
    if лево > право {
        return -1
    }
    
    середина := (лево + право) / 2
    
    if массив[середина] == цель {
        return середина
    }
    
    if массив[середина] > цель {
        // Ищем в левой половине
        return бинарныйПоиск(массив, цель, лево, середина-1)
    }
    
    // Ищем в правой половине
    return бинарныйПоиск(массив, цель, середина+1, право)
}

// Рекурсивный расчет НОД (наибольший общий делитель) по алгоритму Евклида
func нод(a, b int) int {
    if b == 0 {
        return a
    }
    
    return нод(b, a%b)
}

// Рекурсивный обход дерева (имитация)
type УзелДерева struct {
    значение  int
    дети      []*УзелДерева
}

func обойтиДерево(узел *УзелДерева) {
    if узел == nil {
        return
    }
    
    // Обрабатываем текущий узел
    fmt.Printf("%d ", узел.значение)
    
    // Рекурсивно обходим всех детей
    for _, ребенок := range узел.дети {
        обойтиДерево(ребенок)
    }
}

// Рекурсивная функция для подсчета глубины дерева
func глубинаДерева(узел *УзелДерева) int {
    if узел == nil {
        return 0
    }
    
    if len(узел.дети) == 0 {
        return 1
    }
    
    максимальнаяГлубина := 0
    for _, ребенок := range узел.дети {
        глубина := глубинаДерева(ребенок)
        if глубина > максимальнаяГлубина {
            максимальнаяГлубина = глубина
        }
    }
    
    return максимальнаяГлубина + 1
}

// Рекурсивная функция для вычисления палиндрома
func являетсяПалиндромом(строка string) bool {
    // Убираем пробелы и приводим к нижнему регистру
    строка = strings.ToLower(strings.ReplaceAll(строка, " ", ""))
    
    // Вспомогательная рекурсивная функция
    var проверить func(int, int) bool
    проверить = func(лево, право int) bool {
        // Базовые случаи
        if лево >= право {
            return true
        }
        
        if строка[лево] != строка[право] {
            return false
        }
        
        // Рекурсивный случай
        return проверить(лево+1, право-1)
    }
    
    return проверить(0, len(строка)-1)
}

func main() {
    fmt.Println("=== Рекурсивные функции ===")
    
    // Факториал
    fmt.Println("\n=== Факториал ===")
    for n := 0; n <= 10; n++ {
        fmt.Printf("%d! = %d\n", n, факториал(n))
    }
    
    // Числа Фибоначчи
    fmt.Println("\n=== Числа Фибоначчи ===")
    for n := 0; n <= 10; n++ {
        fmt.Printf("F(%d) = %d\n", n, фибоначчи(n))
    }
    
    // Сумма чисел
    fmt.Println("\n=== Сумма чисел от 1 до n ===")
    for n := 1; n <= 10; n++ {
        fmt.Printf("Сумма от 1 до %d = %d\n", n, суммаДо(n))
    }
    
    // Возведение в степень
    fmt.Println("\n=== Возведение в степень ===")
    основание := 2.0
    for показатель := 0; показатель <= 5; показатель++ {
        fmt.Printf("%.0f^%d = %.0f\n", основание, показатель, степень(основание, показатель))
    }
    
    основание = 3.0
    показатель := -2
    fmt.Printf("%.0f^%d = %.3f\n", основание, показатель, степень(основание, показатель))
    
    // Бинарный поиск
    fmt.Println("\n=== Бинарный поиск ===")
    массив := []int{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}
    цель := 13
    
    индекс := бинарныйПоиск(массив, цель, 0, len(массив)-1)
    if индекс != -1 {
        fmt.Printf("Элемент %d найден на позиции %d\n", цель, индекс)
    } else {
        fmt.Printf("Элемент %d не найден\n", цель)
    }
    
    цель = 8
    индекс = бинарныйПоиск(массив, цель, 0, len(массив)-1)
    if индекс != -1 {
        fmt.Printf("Элемент %d найден на позиции %d\n", цель, индекс)
    } else {
        fmt.Printf("Элемент %d не найден\n", цель)
    }
    
    // НОД
    fmt.Println("\n=== Наибольший общий делитель (НОД) ===")
    пары := [][2]int{
        {48, 18},
        {56, 98},
        {1071, 462},
        {17, 13},
    }
    
    for _, пара := range пары {
        a, b := пара[0], пара[1]
        fmt.Printf("НОД(%d, %d) = %d\n", a, b, нод(a, b))
    }
    
    // Обход дерева
    fmt.Println("\n=== Обход дерева ===")
    
    // Создаем простое дерево
    дерево := &УзелДерева{
        значение: 1,
        дети: []*УзелДерева{
            {
                значение: 2,
                дети: []*УзелДерева{
                    {значение: 4},
                    {значение: 5},
                },
            },
            {
                значение: 3,
                дети: []*УзелДерева{
                    {значение: 6},
                    {
                        значение: 7,
                        дети: []*УзелДерева{
                            {значение: 8},
                            {значение: 9},
                        },
                    },
                },
            },
        },
    }
    
    fmt.Println("Обход дерева:")
    обойтиДерево(дерево)
    fmt.Println()
    
    fmt.Printf("Глубина дерева: %d\n", глубинаДерева(дерево))
    
    // Палиндромы
    fmt.Println("\n=== Проверка палиндромов ===")
    
    тестовыеСтроки := []string{
        "А роза упала на лапу Азора",
        "Кот",
        "Шалаш",
        "Madam, I'm Adam",
        "Level",
        "Не палиндром",
    }
    
    for _, строка := range тестовыеСтроки {
        результат := являетсяПалиндромом(строка)
        fmt.Printf("'%s' - палиндром? %v\n", строка, результат)
    }
    
    // Осторожно: глубокая рекурсия может привести к переполнению стека
    fmt.Println("\n=== Предупреждение о глубокой рекурсии ===")
    
    // Попытка вычислить факториал большого числа может вызвать переполнение стека
    // fmt.Println("Факториал 10000:", факториал(10000)) // Опасно!
    
    // Для глубокой рекурсии лучше использовать итеративный подход или хвостовую рекурсию
    // (хотя Go не оптимизирует хвостовую рекурсию)
    
    // Итеративная версия факториала (для сравнения)
    факториалИтеративный := func(n int) int {
        результат := 1
        for i := 2; i <= n; i++ {
            результат *= i
        }
        return результат
    }
    
    fmt.Println("Итеративный факториал 10:", факториалИтеративный(10))
    fmt.Println("Рекурсивный факториал 10:", факториал(10))
}

Объяснение:
Базовый случай — условие, при котором рекурсия останавливается.
Рекурсивный случай — вызов функции самой себя с измененными параметрами.
Глубина рекурсии — количество вложенных вызовов, ограничено размером стека.
Хвостовая рекурсия — когда рекурсивный вызов является последней операцией (Go не оптимизирует).
Применение рекурсии — обход деревьев, математические последовательности, алгоритмы "разделяй и властвуй".

Задание для самостоятельной работы 6:
Создайте рекурсивную функцию для вычисления суммы цифр числа
Реализуйте рекурсивную функцию для проверки, является ли число простым
Создайте рекурсивную функцию для генерации всех перестановок строки
Реализуйте алгоритм быстрой сортировки (quicksort) с рекурсией

Итоги урока
Что вы узнали:
Базовые функции — определение, вызов, параметры, возвращаемые значения
Множественные возвращаемые значения — возврат нескольких значений из функции
Именованные возвращаемые значения — улучшение читаемости и naked return
Функции как значения — присваивание переменным, передача как аргументов
Замыкания — функции, захватывающие переменные из окружающего контекста
Рекурсивные функции — функции, вызывающие сами себя

Ключевые моменты:
Функции инкапсулируют логику и делают код переиспользуемым
Go поддерживает множественные возвращаемые значения (особенно полезно для возврата результата и ошибки)
Именованные возвращаемые значения улучшают читаемость, но naked return следует использовать осторожно
Функции — первоклассные объекты в Go (можно присваивать, передавать, возвращать)
Замыкания полезны для создания функций с состоянием
Рекурсия полезна для определенных типов задач, но может привести к переполнению стека

Распространенные ошибки:
Забыть проверить возвращаемую ошибку — всегда проверяйте ошибки!
Использовать naked return в больших функциях — ухудшает читаемость
Глубокая рекурсия без условия выхода — приводит к переполнению стека
Захват указателей в замыканиях — может привести к неожиданному поведению
Игнорирование возвращаемых значений — используйте _ для явного игнорирования

Что практиковать дальше:
Интерфейсы — полиморфизм через интерфейсы
Горутины и каналы — конкурентное программирование
Тестирование — написание тестов для функций
Оптимизация — профилирование и оптимизация производительности функций

Финальный проект:
Создайте пакет утилит с функциями:

Математические утилиты — статистика, преобразования, расчеты
Строковые утилиты — форматирование, парсинг, валидация
Временные утилиты — конвертация, форматирование, расчеты
Файловые утилиты — чтение, запись, анализ файлов
Функции высшего порядка — map, filter, reduce для различных типов данных

Совет: Начните с простых функций, затем добавляйте более сложные. Пишите тесты для каждой функции. Экспериментируйте с разными подходами и стилями.

Функции — это сердце программирования на Go. Освоив их, вы сможете создавать чистый, модульный и поддерживаемый код. Практикуйтесь, пробуйте разные подходы, и вскоре вы будете писать идиоматичный Go-код с легкостью!