Практическое введение в программирование на Go
Для тех, кто никогда не программировал
Введение
Go (или Golang) — современный язык программирования, созданный в Google. Он сочетает простоту для новичков и мощь для профессиональной разработки. В этом практикуме мы шаг за шагом создадим несколько программ, понимая не только "как", но и "почему" они работают.

Шаг 0: Подготовка и первое знакомство
Цель: Убедиться, что Go установлен, и понять, как мы будем с ним работать.
Концепция: Программирование — это создание инструкций для компьютера. Эти инструкции пишутся на специальном языке (Go), который затем переводится в команды, понятные компьютеру.
Практика:
Откройте терминал (Командную строку):
Windows: Нажмите Win + R, введите cmd, нажмите Enter
MacOS: Откройте "Терминал" через Spotlight (Cmd + Space)
Linux: Откройте терминал (Ctrl + Alt + T)

Проверим установку Go:

go version

Вы должны увидеть что-то вроде: go version go1.21.0 darwin/amd64

Узнаем, где установлен Go:

go env GOROOT

Объяснение: Команда go version показывает версию установленного Go. Убедиться, что Go установлен правильно — первый шаг, потому что без него мы не сможем выполнять наши программы.

Шаг 1: Структура проекта и первая программа
Цель: Создать правильную структуру папок и написать простейшую программу.
Концепция: В Go каждая программа — это набор файлов в определенной структуре папок. Это помогает организовывать код и управлять зависимостями.
Практика:
Создаем основную папку для обучения:

mkdir go-learning
cd go-learning

Создаем папку для первой программы (важно: одна программа — одна папка):
mkdir hello-world
cd hello-world
Создаем файл main.go:

Через редактор кода (рекомендуется VS Code)
Или через терминал:
Windows: notepad main.go
MacOS/Linux: touch main.go
Пишем код в main.go:

package main  // Объявляем главный пакет программы
import "fmt"  // Подключаем пакет fmt для работы с вводом-выводом
func main() { // Определяем главную функцию
    fmt.Println("Привет, мир!") // Выводим текст в консоль
    fmt.Println("Я изучаю Go!")
}

Запускаем программу:

go run main.go

Объяснение:
package main — каждый файл Go начинается с объявления пакета. Пакет main особый — он указывает, что это главная программа, которую можно запустить.
import "fmt" — мы "импортируем" (подключаем) пакет fmt, который содержит функции для вывода текста. Без него мы не смогли бы использовать Println.
func main() — функция main — это точка входа. Когда вы запускаете программу, Go ищет функцию с именем main и выполняет код внутри нее.
fmt.Println() — функция вывода текста с переходом на новую строку.

Что происходит при запуске:
Команда go run main.go говорит Go: "скомпилируй и сразу выполни этот файл"
Go читает файл, проверяет синтаксис
Находит функцию main и выполняет команды внутри нее построчно
Каждая команда fmt.Println отправляет текст в стандартный вывод (ваш терминал)

Задание для самостоятельной работы:
Измените текст в кавычках на свой
Добавьте еще одну строку вывода
Попробуйте убрать import "fmt" и посмотрите на ошибку

Шаг 2: Различные способы вывода информации
Цель: Познакомиться с разными функциями вывода и понять их отличия.
Концепция: В программировании важно уметь выводить информацию в нужном формате. Пакет fmt предлагает несколько функций для этого.
Практика:

package main

import "fmt"

func main() {
    // Println - выводит с новой строки после текста
    fmt.Println("Строка 1")
    fmt.Println("Строка 2")
    
    // Print - выводит без перехода на новую строку
    fmt.Print("Это ")
    fmt.Print("будет ")
    fmt.Print("в одной строке")
    fmt.Println() // Пустой Println для перехода на новую строку
    
    // Printf - выводит с форматированием
    // %d - целое число, %f - дробное число, %s - строка
    fmt.Printf("Мне %d лет\n", 25)
    fmt.Printf("Температура: %.1f градусов\n", 23.5)
    fmt.Printf("Меня зовут %s\n", "Алексей")
}

Объяснение:
Println (Print Line) — выводит текст и автоматически переходит на новую строку. Удобно для разделения вывода.
Print — выводит текст без перехода на новую строку. Следующий вывод продолжается в той же строке.
Printf (Print Formatted) — позволяет вставлять значения переменных в текст, используя специальные символы форматирования:
%d — для целых чисел (decimal)
%f — для дробных чисел (float). %.1f означает "одна цифра после запятой"
%s — для строк (string)
\n — специальный символ перехода на новую строку

Задание для самостоятельной работы:
Создайте программу, которая выводит информацию о вас в формате:

Имя: [ваше имя]
Возраст: [ваш возраст] лет
Город: [ваш город]
Используйте все три способа вывода в одной программе

Шаг 3: Переменные и типы данных
Цель: Научиться хранить информацию в переменных и понимать типы данных.
Концепция: Переменная — это именованная область памяти для хранения данных. Тип данных определяет, какую информацию может хранить переменная и какие операции с ней можно выполнять.
Теория: Основные типы данных в Go:

string — текст (например, "Привет")
int — целые числа (например, 42, -10)
float64 — дробные числа (например, 3.14, -2.5)
bool — логические значения (true или false)

Практика:

go
package main

import "fmt"

func main() {
    // Способ 1: Полное объявление с указанием типа
    var имя string = "Мария"   // Переменная для текста
    var возраст int = 30       // Переменная для целых чисел
    var рост float64 = 1.75    // Переменная для дробных чисел
    var студент bool = true    // Переменная для true/false
    
    fmt.Println("Имя:", имя)
    fmt.Println("Возраст:", возраст)
    fmt.Println("Рост:", рост, "м")
    fmt.Println("Студент:", студент)
    
    // Способ 2: Краткое объявление (Go сам определяет тип)
    город := "Москва"          // Go понимает, что это string
    температура := -5.3        // Go понимает, что это float64
    
    fmt.Println("Город:", город)
    fmt.Println("Температура:", температура, "°C")
    
    // Изменение значения переменной
    возраст = 31  // Меняем значение с 30 на 31
    fmt.Println("В следующем году мне будет:", возраст)
}

Объяснение:
Ключевое слово var создает новую переменную. После var идет имя переменной, затем тип, затем значение.
Синтаксис := (короткое объявление) позволяет создать переменную без указания типа. Go определяет тип автоматически по присваиваемому значению.
Знак = используется для присваивания значения уже существующей переменной.
Зачем нужны типы данных:
Безопасность — компилятор проверяет, что вы не пытаетесь, например, сложить строку с числом
Эффективность — разные типы данных хранятся по-разному в памяти
Понятность — глядя на тип, можно понять, что хранится в переменной

Задание для самостоятельной работы:
Создайте переменные для хранения информации о вашем любимом фильме:

Название (string)
Год выхода (int)
Рейтинг (float64)
Понравился (bool)

Выведите все переменные в удобном формате

Шаг 4: Базовые операции и работа со строками
Цель: Научиться выполнять математические операции и работать с текстом.
Концепция: Компьютеры отлично справляются с вычислениями и обработкой текста. В Go есть операторы для арифметики и функции для работы со строками.
Практика:

go
package main

import (
    "fmt"
    "strings"  // Подключаем пакет для работы со строками
)

func main() {
    // Математические операции с целыми числами
    a := 10
    b := 3
    
    fmt.Println("a =", a, ", b =", b)
    fmt.Println("a + b =", a + b)  // Сложение
    fmt.Println("a - b =", a - b)  // Вычитание
    fmt.Println("a * b =", a * b)  // Умножение
    fmt.Println("a / b =", a / b)  // Деление нацело (целая часть)
    fmt.Println("a % b =", a % b)  // Остаток от деления
    
    // Деление с дробными числами
    x := 10.0
    y := 3.0
    fmt.Println("x / y =", x / y)  // Обычное деление с дробной частью
    
    // Работа со строками
    имя := "Иван"
    фамилия := "Петров"
    
    // Конкатенация (объединение) строк
    полноеИмя := имя + " " + фамилия
    fmt.Println("Полное имя:", полноеИмя)
    
    // Длина строки
    fmt.Println("Длина имени:", len(имя), "символов")
    
    // Повторение строки (используем пакет strings)
    fmt.Println(strings.Repeat("*", 30))
    fmt.Println("    ПРИВЕТСТВИЕ    ")
    fmt.Println(strings.Repeat("*", 30))
}

Объяснение:
Арифметические операторы: +, -, *, /, % (остаток от деления)
Важное различие: Деление целых чисел (10 / 3 = 3) дает целую часть. Деление дробных чисел (10.0 / 3.0 = 3.333...) дает точный результат.

Работа со строками:
+ объединяет строки
len() возвращает длину строки в символах
strings.Repeat("*", 30) повторяет строку "*" 30 раз (требует импорта пакета strings)

Задание для самостоятельной работы:
Создайте простой калькулятор, который выводит результаты всех операций для двух чисел
Создайте рамку из символов вокруг любого текста
Попробуйте сложить число и строку — посмотрите на ошибку

Шаг 5: Ввод данных от пользователя
Цель: Научиться получать данные от пользователя во время работы программы.
Концепция: Программы становятся полезными, когда они могут взаимодействовать с пользователем. Функция Scan позволяет читать ввод с клавиатуры.

Практика:

package main

import "fmt"

func main() {
    // Объявляем переменные для хранения введенных данных
    var имя string
    var возраст int
    
    // Запрашиваем и читаем имя
    fmt.Print("Введите ваше имя: ")
    fmt.Scan(&имя)  // & - оператор взятия адреса переменной
    
    // Запрашиваем и читаем возраст
    fmt.Print("Введите ваш возраст: ")
    fmt.Scan(&возраст)
    
    // Выводим результат
    fmt.Println("-------------------")
    fmt.Printf("Привет, %s!\n", имя)
    fmt.Printf("Тебе %d лет.\n", возраст)
    
    // Простая проверка условия
    if возраст >= 18 {
        fmt.Println("Ты совершеннолетний(ая)!")
    } else {
        fmt.Println("Ты еще несовершеннолетний(ая).")
    }
}

Объяснение:
fmt.Scan(&переменная) — функция, которая ждет, пока пользователь введет данные и нажмет Enter, затем сохраняет введенное значение в переменную.
Символ & перед именем переменной означает "адрес этой переменной в памяти". Мы говорим функции Scan: "положи введенное значение В эту конкретную ячейку памяти".
if возраст >= 18 — условный оператор. Он проверяет условие в скобках и выполняет код в фигурных скобках, если условие истинно.

Что происходит:
Программа выводит приглашение ко вводу
Останавливается и ждет, пока пользователь что-то введет
Сохраняет введенное значение в переменную
Продолжает выполнение с использованием этого значения

Задание для самостоятельной работы:
Создайте программу, которая запрашивает у пользователя город и страну, затем выводит их
Добавьте запрос роста и веса, вычислите и выведите индекс массы тела (вес / рост²)
Попробуйте ввести не число, когда программа ждет число — посмотрите, что произойдет

Шаг 6: Простой калькулятор с условиями
Цель: Создать программу, которая выполняет разные действия в зависимости от выбора пользователя.
Концепция: Часто программа должна выполнять разные действия в зависимости от условий. Конструкция switch позволяет выбирать между несколькими вариантами.

Практика:

package main

import "fmt"

func main() {
    // Объявляем переменные
    var a, b float64
    var операция string
    
    fmt.Println("=== Простой калькулятор ===")
    
    // Ввод первого числа
    fmt.Print("Введите первое число: ")
    fmt.Scan(&a)
    
    // Ввод операции
    fmt.Print("Введите операцию (+, -, *, /): ")
    fmt.Scan(&операция)
    
    // Ввод второго числа
    fmt.Print("Введите второе число: ")
    fmt.Scan(&b)
    
    // Разделительная линия
    fmt.Println("-------------------")
    
    // Переменная для результата
    var результат float64
    // Переменная для сообщения об ошибке
    var ошибка string = ""  // Пустая строка означает "ошибок нет"
    
    // Выбор операции
    switch операция {
    case "+":
        результат = a + b
        fmt.Printf("%.2f + %.2f = %.2f\n", a, b, результат)
    case "-":
        результат = a - b
        fmt.Printf("%.2f - %.2f = %.2f\n", a, b, результат)
    case "*":
        результат = a * b
        fmt.Printf("%.2f * %.2f = %.2f\n", a, b, результат)
    case "/":
        // Проверка деления на ноль
        if b != 0 {
            результат = a / b
            fmt.Printf("%.2f / %.2f = %.2f\n", a, b, результат)
        } else {
            ошибка = "Ошибка: деление на ноль!"
        }
    default:
        ошибка = "Ошибка: неизвестная операция!"
    }
    
    // Если есть ошибка, выводим ее
    if ошибка != "" {
        fmt.Println(ошибка)
    }
}

Объяснение:
switch операция — проверяет значение переменной операция и выполняет соответствующий блок кода
case "+": — если операция равна "+", выполняется этот блок
default: — выполняется, если ни один case не подошел (как "во всех остальных случаях")
if b != 0 — проверка, что делитель не равен нулю (деление на ноль — математическая ошибка)
%.2f в Printf — формат для вывода дробных чисел с двумя знаками после запятой

Зачем нужен switch:
Читабельнее, чем цепочка if-else if
Удобно, когда нужно проверить много конкретных значений

Задание для самостоятельной работы:
Добавьте операцию возведения в степень (используйте math.Pow из пакета math)
Добавьте операцию вычисления процента (a % от b)
Сделайте так, чтобы программа могла принимать дробные числа с запятой, а не только с точкой

Шаг 7: Игра "Угадай число" с циклом
Цель: Создать игру с повторяющимися действиями и случайными числами.
Концепция: Циклы позволяют повторять блок кода несколько раз. Случайные числа делают программу непредсказуемой и интересной.
Теория:

for { ... } — бесконечный цикл. Выполняет код в фигурных скобках снова и снова, пока не встретится break
rand.Intn(100) — генерирует случайное число от 0 до 99
rand.Seed(time.Now().UnixNano()) — инициализирует генератор случайных чисел текущим временем, чтобы числа были разными при каждом запуске

Практика:

go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

func main() {
    // Инициализируем генератор случайных чисел текущим временем
    // Иначе при каждом запуске будут одни и те же "случайные" числа
    rand.Seed(time.Now().UnixNano())
    
    // Загадываем число от 1 до 100
    secretNumber := rand.Intn(100) + 1
    
    fmt.Println("=== Игра 'Угадай число' ===")
    fmt.Println("Я загадал число от 1 до 100.")
    fmt.Println("Попробуй угадать!")
    
    var попытка int
    попытки := 0
    
    // Бесконечный цикл - будет выполняться, пока не сработает break
    for {
        попытки++
        
        fmt.Print("\nВведите вашу догадку: ")
        fmt.Scan(&попытка)
        
        if попытка < secretNumber {
            fmt.Println("Слишком маленькое число!")
        } else if попытка > secretNumber {
            fmt.Println("Слишком большое число!")
        } else {
            // Угадали - выходим из цикла
            fmt.Printf("\nПоздравляю! Вы угадали!\n")
            fmt.Printf("Загаданное число: %d\n", secretNumber)
            fmt.Printf("Количество попыток: %d\n", попытки)
            
            // Оценка результата
            switch {
            case попытки <= 5:
                fmt.Println("Вы гений!")
            case попытки <= 10:
                fmt.Println("Хороший результат!")
            default:
                fmt.Println("Попробуйте еще раз, будет лучше!")
            }
            break  // Выход из цикла
        }
        
        // Подсказка после 5 попыток
        if попытки == 5 {
            if secretNumber % 2 == 0 {
                fmt.Println("Подсказка: число четное!")
            } else {
                fmt.Println("Подсказка: число нечетное!")
            }
        }
    }
}

Объяснение:
Инициализация случайных чисел: rand.Seed(time.Now().UnixNano()) — без этого вызовы rand.Intn() будут возвращать одни и те же числа
Генерация числа: rand.Intn(100) дает число от 0 до 99, поэтому +1 дает диапазон 1-100
Бесконечный цикл: for { ... } выполняется бесконечно, пока не выполнится break
Условия: if-else if-else проверяет, больше, меньше или равно введенное число загаданному
Подсказка: secretNumber % 2 == 0 проверяет четность числа (остаток от деления на 2 равен 0)

Зачем нужны циклы:
Обработка повторяющихся действий
Работа до достижения условия
Обработка пользовательского ввода, пока он не введет корректные данные

Задание для самостоятельной работы:
Добавьте ограничение на количество попыток (например, 15)
Сделайте выбор уровня сложности (разные диапазоны чисел)
Добавьте подсчет очков: чем меньше попыток, тем больше очков

Итоги и дальнейшие шаги
Что вы научились делать:
Устанавливать и проверять Go
Создавать структуру проекта
Писать простые программы с выводом информации
Работать с переменными разных типов
Выполнять математические операции
Получать ввод от пользователя
Использовать условия (if-else, switch)
Создавать циклы для повторяющихся действий
Генерировать случайные числа
Основные концепции, которые вы теперь понимаете:
Программа выполняется построчно, сверху вниз
Данные имеют типы, которые определяют возможные операции
Пакеты содержат готовые функции для разных задач
Переменные хранят данные в памяти
Условия позволяют программе "принимать решения"
Циклы повторяют действия
Функции организуют код в логические блоки

Что изучать дальше:
Массивы и срезы — хранение наборов данных
Карты (maps) — хранение данных по ключам
Структуры (structs) — создание собственных типов данных
Функции с параметрами и возвращаемыми значениями
Обработка ошибок
Работа с файлами
Создание веб-серверов (сильная сторона Go)
Практические задачи для закрепления:
Создайте программу для конвертации валют
Напишите игру "Камень-ножницы-бумага"
Создайте простой список дел (todo list)
Реализуйте программу для шифрования/дешифрования текста (шифр Цезаря)

Советы для дальнейшего обучения:
Пишите код каждый день — даже по 30 минут
Читайте чужой код — изучайте открытые проекты на GitHub
Решайте задачи — на сайтах вроде LeetCode, Codewars
Создавайте свои проекты — лучше всего учиться на практике
Изучайте официальную документацию — https://golang.org/doc/

Помните: каждый программист когда-то начинал с "Привет, мир!". Главное — продолжать практиковаться и не бояться ошибок. Они — лучший способ учиться.