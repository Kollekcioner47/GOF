Практическое введение в массивы и среза в Go
Теоретическое введение
Цель урока: Научиться работать с коллекциями данных — массивами и срезами.

Концепция: В программировании часто нужно работать не с одной переменной, а с набором данных. Например:
Список студентов в группе
Температуры за неделю
Товары в корзине покупок
Два основных типа коллекций в Go:
Массивы (Arrays) — фиксированный набор элементов одного типа. Размер массива определяется при создании и не может меняться.
Срезы (Slices) — динамические "окна" в массивы. Могут менять размер. Это более гибкая и часто используемая структура.

Шаг 1: Массивы — фиксированные коллекции
Цель: Понять, как создавать и использовать массивы фиксированного размера.

Теория:
Массив имеет фиксированную длину, которая задается при объявлении
Все элементы должны быть одного типа
Индексация начинается с 0
Размер массива является частью его типа (например, [5]int и [10]int — разные типы)

Практика:
go
package main

import "fmt"

func main() {
    // Способ 1: Объявление с последующим заполнением
    var оценки [5]int  // Массив из 5 целых чисел
    
    // Заполняем массив значениями
    оценки[0] = 4  // Первый элемент (индекс 0)
    оценки[1] = 5  // Второй элемент (индекс 1)
    оценки[2] = 3
    оценки[3] = 4
    оценки[4] = 5  // Последний элемент (индекс 4 = длина-1)
    
    // Способ 2: Объявление с инициализацией
    дниНедели := [7]string{
        "Понедельник",
        "Вторник",
        "Среда",
        "Четверг",
        "Пятница",
        "Суббота",
        "Воскресенье",
    }
    
    // Способ 3: Автоматическое определение размера
    температуры := [...]float64{22.5, 23.1, 21.8, 24.3, 20.5}
    // Компилятор сам посчитает, что здесь 5 элементов
    
    // Выводим массивы
    fmt.Println("Оценки студента:", оценки)
    fmt.Println("Дни недели:", дниНедели)
    fmt.Println("Температуры за неделю:", температуры)
    
    // Работа с отдельными элементами
    fmt.Println("\n--- Работа с элементами ---")
    fmt.Println("Первая оценка:", оценки[0])
    fmt.Println("Третий день недели:", дниНедели[2])
    fmt.Println("Средняя температура в среду:", температуры[2], "°C")
    
    // Изменение элемента
    оценки[2] = 5  // Изменяем третью оценку
    fmt.Println("Исправленные оценки:", оценки)
    
    // Длина массива
    fmt.Println("Количество дней в неделе:", len(дниНедели))
    fmt.Println("Количество температурных измерений:", len(температуры))
    
    // Перебор массива (цикл for)
    fmt.Println("\n--- Перебор элементов ---")
    fmt.Println("Температуры по дням:")
    for i := 0; i < len(температуры); i++ {
        fmt.Printf("День %d: %.1f°C\n", i+1, температуры[i])
    }
}
Объяснение:
var оценки [5]int — создаем массив на 5 элементов типа int. По умолчанию все элементы равны 0.

оценки[0] = 4 — обращаемся к первому элементу массива. Индексы всегда начинаются с 0.

[...]float64{22.5, 23.1, ...} — ... означает, что компилятор сам посчитает количество элементов.

len(дниНедели) — функция len() возвращает длину массива.

Цикл for i := 0; i < len(температуры); i++ — стандартный способ перебора массива.

Что произойдет, если обратиться к несуществующему элементу:
go
package main

import "fmt"

func main() {
    arr := [3]int{1, 2, 3}
    fmt.Println(arr[5])  // Ошибка: выход за границы массива
    // Компилятор может не заметить, но при запуске программа упадет с panic
}
Задание для самостоятельной работы 1:
Создайте массив из 6 элементов с названиями месяцев (с января по июнь)
Выведите все месяцы построчно
Измените название третьего месяца на "Март (весна!)"
Выведите последний месяц
Подсчитайте и выведите количество месяцев в массиве

Шаг 2: Срезы — динамические коллекции
Цель: Понять, как создавать и использовать срезы, которые могут менять размер.

Теория:
Срез — это "окно" в массив, но без фиксированного размера
Срезы могут расти и сокращаться
Под капотом срез содержит указатель на массив, длину и вместимость (capacity)
Это основная структура для работы с коллекциями в Go

Практика:
go
package main

import "fmt"

func main() {
    // Способ 1: Создание среза (пустой, но готовый к добавлению)
    var студенты []string  // Пустой срез строк
    
    // Добавление элементов в срез
    студенты = append(студенты, "Анна")
    студенты = append(студенты, "Борис")
    студенты = append(студенты, "Виктор")
    
    // Способ 2: Создание среза с начальными значениями
    оценки := []int{5, 4, 3, 5, 4}
    
    // Способ 3: Создание среза заданной длины и вместимости
    товары := make([]string, 0, 10)  // Длина 0, вместимость 10
    
    // Добавляем товары
    товары = append(товары, "Молоко")
    товары = append(товары, "Хлеб")
    товары = append(товары, "Яйца")
    
    fmt.Println("Студенты:", студенты, "Длина:", len(студенты))
    fmt.Println("Оценки:", оценки, "Длина:", len(оценки))
    fmt.Println("Товары:", товары, "Длина:", len(товары), "Вместимость: неизвестна")
    
    // Получение элементов среза
    fmt.Println("\n--- Доступ к элементам ---")
    fmt.Println("Первый студент:", студенты[0])
    fmt.Println("Вторая оценка:", оценки[1])
    fmt.Println("Последний товар:", товары[len(товары)-1])  // Индекс последнего элемента
    
    // Изменение элементов
    оценки[2] = 5  // Изменяем третью оценку
    fmt.Println("Исправленные оценки:", оценки)
    
    // Перебор среза
    fmt.Println("\n--- Перебор среза ---")
    fmt.Println("Список студентов:")
    for i, студент := range студенты {
        fmt.Printf("%d. %s\n", i+1, студент)
    }
    
    // Динамическое добавление элементов
    fmt.Println("\n--- Динамическое изменение ---")
    fmt.Println("Изначальный срез товаров:", товары)
    
    // Добавляем несколько элементов сразу
    товары = append(товары, "Сыр", "Колбаса", "Сок")
    fmt.Println("После добавления:", товары)
    
    // Удаление элемента (например, второго)
    товары = append(товары[:1], товары[2:]...)
    fmt.Println("После удаления второго элемента:", товары)
}

Объяснение:
var студенты []string — создаем пустой срез строк. Он равен nil.
append(студенты, "Анна") — добавляет элемент в конец среза. Возвращает новый срез.
make([]string, 0, 10) — создает срез с длиной 0 и вместимостью 10. Вместимость — это размер внутреннего массива.
len(товары)-1 — индекс последнего элемента (длина - 1).
Цикл for i, студент := range студенты — специальный синтаксис для перебора срезов. i — индекс, студент — значение.
append(товары, "Сыр", "Колбаса", "Сок") — можно добавлять несколько элементов за раз.
товары[:1] — срез, содержащий элементы с индекса 0 до 1 (не включая 1).
товары[2:] — срез, содержащий элементы с индекса 2 до конца.
... — оператор распаковки среза в аргументы функции.

Задание для самостоятельной работы 2:
Создайте срез для хранения ежедневных трат за неделю
Добавьте 7 значений трат
Вычислите и выведите:
Общую сумму трат
Среднюю дневную трату
Максимальную трату (используйте цикл для поиска)
Удалите трату за выходные (последние 2 дня)
Добавьте новую трату "накопления" в размере 10% от общей суммы

Шаг 3: Срезы как "окна" в массивы
Цель: Понять связь между массивами и срезами.

Теория:
Срез не хранит данные самостоятельно, а ссылается на часть массива
Несколько срезов могут ссылаться на один и тот же массив
Изменение элемента через срез меняет исходный массив

Практика:
go
package main

import "fmt"

func main() {
    // Создаем массив
    месяцы := [12]string{
        "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
        "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь",
    }
    
    fmt.Println("Полный массив месяцев:", месяцы)
    fmt.Println("Длина массива:", len(месяцы))
    
    // Создаем срезы (окна) в этот массив
    зима := месяцы[0:3]    // Индексы 0, 1, 2 (Январь-Март)
    весна := месяцы[3:6]   // Индексы 3, 4, 5 (Апрель-Июнь)
    лето := месяцы[6:9]    // Индексы 6, 7, 8 (Июль-Сентябрь)
    осень := месяцы[9:12]  // Индексы 9, 10, 11 (Октябрь-Декабрь)
    
    // Синтаксический сахар: опускание границ
    первоеПолугодие := месяцы[:6]   // С начала до 6 индекса (не включая)
    второеПолугодие := месяцы[6:]   // С 6 индекса до конца
    
    fmt.Println("\n--- Времена года ---")
    fmt.Println("Зима:", зима)
    fmt.Println("Весна:", весна)
    fmt.Println("Лето:", лето)
    fmt.Println("Осень:", осень)
    
    fmt.Println("\n--- Полугодия ---")
    fmt.Println("Первое полугодие:", первоеПолугодие)
    fmt.Println("Второе полугодие:", второеПолугодие)
    
    // Изменяем через срез — меняется массив!
    зима[0] = "ЯНВАРЬ (морозный)"
    fmt.Println("\nПосле изменения через срез:")
    fmt.Println("Срез зима:", зима)
    fmt.Println("Исходный массив:", месяцы)  // Первый элемент изменился!
    
    // Создаем копию среза (независимую)
    копияЗимы := make([]string, len(зима))
    copy(копияЗимы, зима)  // Копируем элементы
    
    // Меняем копию
    копияЗимы[1] = "ФЕВРАЛЬ (снежный)"
    fmt.Println("\nСравнение среза и его копии:")
    fmt.Println("Исходный срез зима:", зима)
    fmt.Println("Копия зимы:", копияЗимы)
    fmt.Println("Исходный массив:", месяцы)  // Не изменился от изменения копии
}

Объяснение:
месяцы[0:3] — создает срез, включающий элементы с индексами 0, 1, 2. Верхняя граница не включается.
месяцы[:6] — если опустить начало, берется с 0 индекса.
месяцы[6:] — если опустить конец, берется до конца массива.
Изменение среза влияет на массив — потому что срез ссылается на массив.
copy(копияЗимы, зима) — создает настоящую копию элементов в новую область памяти.

Важное замечание о вместимости (capacity):
go
package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    slice := arr[1:4]  // Срез [2, 3, 4]
    
    fmt.Println("Срез:", slice, "Длина:", len(slice), "Вместимость:", cap(slice))
    // Вместимость = 4 (от индекса 1 до конца массива: элементы 1,2,3,4)
    
    // Можно расширить срез в пределах вместимости
    extendedSlice := slice[:cap(slice)]
    fmt.Println("Расширенный срез:", extendedSlice)  // [2, 3, 4, 5]
}

Задание для самостоятельной работы 3:
Создайте массив чисел от 1 до 20
Создайте срезы:
Четные числа
Нечетные числа
Первые 10 чисел
Последние 5 чисел
Измените третий элемент через срез четных чисел
Проверьте, как изменился исходный массив
Создайте полную копию массива через срез и copy()

Шаг 4: Многомерные структуры
Цель: Научиться работать с таблицами и матрицами.
Теория:
Массивы и срезы могут содержать другие массивы и срезы
Двумерный срез — это таблица (строка — срез, таблица — срез строк)

Практика:
go
package main

import "fmt"

func main() {
    // Двумерный массив (матрица 3x3)
    var матрица [3][3]int
    
    // Заполняем матрицу
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            матрица[i][j] = i*10 + j + 1
        }
    }
    
    fmt.Println("Матрица 3x3:")
    for i := 0; i < 3; i++ {
        fmt.Println(матрица[i])
    }
    
    // Двумерный срез (динамическая таблица)
    fmt.Println("\n--- Динамическая таблица ---")
    
    // Создаем таблицу 3x? (3 строки, разное количество столбцов)
    таблица := make([][]string, 3)
    
    // Инициализируем каждую строку
    таблица[0] = []string{"Имя", "Возраст", "Город"}
    таблица[1] = []string{"Анна", "25", "Москва"}
    таблица[2] = []string{"Борис", "30", "Санкт-Петербург", "Инженер"}  // Разное количество столбцов!
    
    // Выводим таблицу
    fmt.Println("Таблица студентов:")
    for _, строка := range таблица {
        for _, значение := range строка {
            fmt.Printf("%-15s", значение)  // %-15s выравнивание влево на 15 символов
        }
        fmt.Println()
    }
    
    // Добавление новой строки
    новаяСтрока := []string{"Виктор", "28", "Казань"}
    таблица = append(таблица, новаяСтрока)
    
    fmt.Println("\nПосле добавления новой строки:")
    for _, строка := range таблица {
        fmt.Println(строка)
    }
    
    // Практический пример: поле для игры в крестики-нолики
    fmt.Println("\n--- Поле для крестиков-ноликов ---")
    поле := [3][3]string{}
    
    // Заполняем поле
    поле[0][0] = "X"
    поле[1][1] = "O"
    поле[2][2] = "X"
    поле[0][2] = "O"
    
    // Отображаем поле
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if поле[i][j] == "" {
                fmt.Print(" - ")
            } else {
                fmt.Printf(" %s ", поле[i][j])
            }
            if j < 2 {
                fmt.Print("|")
            }
        }
        fmt.Println()
        if i < 2 {
            fmt.Println("---+---+---")
        }
    }
}

Объяснение:
[3][3]int — двумерный массив 3x3 (3 строки, в каждой по 3 элемента).
make([][]string, 3) — создает срез из 3 строк, где каждая строка — это срез строк.
В Go можно иметь "зубчатые" массивы (jagged arrays) — где строки разной длины.
Вложенные циклы — для работы с многомерными структурами.

Задание для самостоятельной работы 4:
Создайте таблицу умножения 10x10
Выведите ее в читаемом виде (с заголовками строк и столбцов)
Создайте срез для хранения недельного расписания:
7 дней (срезы)
В каждом дне разное количество дел
Добавьте минимум 3 дела в каждый день
Реализуйте функцию вывода расписания на экран

Шаг 5: Практические задачи
Задача 1: Анализ оценок
go
package main

import "fmt"

func main() {
    // Задача: проанализировать успеваемость группы
    оценки := []int{5, 4, 3, 5, 2, 4, 5, 3, 4, 5, 4, 3, 2, 5, 4}
    
    // 1. Подсчет количества каждой оценки
    счетчик := [6]int{}  // Индексы 0-5 (0 не используется)
    
    for _, оценка := range оценки {
        счетчик[оценка]++
    }
    
    fmt.Println("Распределение оценок:")
    for i := 5; i >= 2; i-- {
        fmt.Printf("Оценка %d: %d раз(а)\n", i, счетчик[i])
    }
    
    // 2. Средний балл
    сумма := 0
    for _, оценка := range оценки {
        сумма += оценка
    }
    средний := float64(сумма) / float64(len(оценки))
    fmt.Printf("\nСредний балл: %.2f\n", средний)
    
    // 3. Поиск максимальной и минимальной оценки
    макс := оценки[0]
    мин := оценки[0]
    
    for _, оценка := range оценки[1:] {
        if оценка > макс {
            макс = оценка
        }
        if оценка < мин {
            мин = оценка
        }
    }
    
    fmt.Printf("Максимальная оценка: %d\n", макс)
    fmt.Printf("Минимальная оценка: %d\n", мин)
}
Задача 2: Управление списком задач
go
package main

import (
    "fmt"
    "strings"
)

func main() {
    задачи := []string{
        "Купить молоко",
        "Сделать домашку по Go",
        "Позвонить маме",
        "Заплатить за интернет",
    }
    
    for {
        fmt.Println("\n=== Менеджер задач ===")
        fmt.Println("1. Показать все задачи")
        fmt.Println("2. Добавить задачу")
        fmt.Println("3. Удалить задачу")
        fmt.Println("4. Найти задачу")
        fmt.Println("5. Выход")
        
        var выбор int
        fmt.Print("Выберите действие: ")
        fmt.Scan(&выбор)
        
        switch выбор {
        case 1:
            fmt.Println("\nСписок задач:")
            if len(задачи) == 0 {
                fmt.Println("Задач нет!")
            } else {
                for i, задача := range задачи {
                    fmt.Printf("%d. %s\n", i+1, задача)
                }
            }
            
        case 2:
            var новаяЗадача string
            fmt.Print("Введите новую задачу: ")
            fmt.Scanln(&новаяЗадача)  // Считываем строку
            
            // Если строка пустая, используем дополнительное чтение
            if новаяЗадача == "" {
                fmt.Scanln(&новаяЗадача)
            }
            
            задачи = append(задачи, новаяЗадача)
            fmt.Println("Задача добавлена!")
            
        case 3:
            fmt.Print("Введите номер задачи для удаления: ")
            var номер int
            fmt.Scan(&номер)
            
            if номер < 1 || номер > len(задачи) {
                fmt.Println("Неверный номер задачи!")
            } else {
                // Удаляем задачу (индекс = номер-1)
                задачи = append(задачи[:номер-1], задачи[номер:]...)
                fmt.Println("Задача удалена!")
            }
            
        case 4:
            fmt.Print("Введите текст для поиска: ")
            var поиск string
            fmt.Scan(&поиск)
            
            найденные := []string{}
            for _, задача := range задачи {
                if strings.Contains(strings.ToLower(задача), strings.ToLower(поиск)) {
                    найденные = append(найденные, задача)
                }
            }
            
            if len(найденные) == 0 {
                fmt.Println("Задачи не найдены")
            } else {
                fmt.Println("Найденные задачи:")
                for i, задача := range найденные {
                    fmt.Printf("%d. %s\n", i+1, задача)
                }
            }
            
        case 5:
            fmt.Println("Выход из программы")
            return
            
        default:
            fmt.Println("Неверный выбор!")
        }
    }
}

Задание для самостоятельной работы 5:
Модифицируйте менеджер задач:
Добавьте возможность отмечать задачи как выполненные
Реализуйте вывод отдельно выполненных и невыполненных задач
Добавьте приоритет задач (высокий, средний, низкий)
Создайте программу для учета расходов:
Храните дату, категорию и сумму расхода
Реализуйте поиск по категории
Выводите статистику по категориям

Итоги урока
Что вы узнали:
Массивы — фиксированные коллекции одного типа
Срезы — динамические "окна" в массивы
Создание и инициализация массивов и срезов
Доступ к элементам по индексу (начинается с 0)
Изменение элементов массивов и срезов
Перебор элементов с помощью циклов for и range
Добавление элементов в срезы с помощью append
Удаление элементов из срезов
Копирование срезов с помощью copy
Многомерные структуры (матрицы, таблицы)
Практическое применение — менеджер задач, анализ данных

Ключевые моменты:
Массивы имеют фиксированный размер, срезы — динамический
Срезы ссылаются на массивы, изменение среза меняет массив
append может создавать новые массивы при нехватке вместимости
Всегда проверяйте границы при доступе по индексу
Цикл range удобен для перебора, но не позволяет изменять элементы

Распространенные ошибки:
Выход за границы — доступ к arr[len(arr)] (нужен len(arr)-1)
Путаница длины и вместимости — len() vs cap()
Изменение среза во время итерации — может привести к неожиданным результатам
Предположение, что append изменяет исходный срез — он возвращает новый

Что практиковать дальше:
Сортировка срезов — пакет sort
Фильтрация и преобразование срезов
Работа с большими наборами данных — эффективное использование памяти
Пользовательские типы — создание срезов структур

Финальное задание:
Создайте программу для управления библиотекой книг:
Книга имеет: название, автора, год издания, статус (доступна/выдана)

Реализуйте функции:
Добавление новой книги
Поиск книги по названию или автору
Выдача книги (изменение статуса)
Возврат книги
Статистика: сколько книг доступно, сколько выдано
Храните данные в срезах структур
Совет: Начните с определения структуры Book, затем создайте срез для хранения книг, и постепенно реализуйте функционал.
Помните: практика — ключ к освоению. Пишите код, экспериментируйте, делайте ошибки и учитесь на них!