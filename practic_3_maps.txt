Практическое введение в карты (maps) в Go
Теоретическое введение
Цель урока: Научиться работать с картами — структурами данных для хранения пар "ключ-значение".
Концепция: Представьте словарь или телефонную книгу. Вы ищете слово (ключ) и получаете его определение (значение). Карты работают так же — они позволяют быстро находить значение по ключу.

Зачем нужны карты:
Быстрый поиск по ключу (гораздо быстрее, чем перебор массива)
Хранение структурированных данных (пользователи, настройки, кэш)
Группировка данных (статистика по категориям)

Основные характеристики:
Ключи должны быть уникальными
Ключи и значения могут быть разных типов, но все ключи одного типа и все значения одного типа
Порядок элементов не гарантируется (не упорядочены)
Быстрые операции: добавление, поиск, удаление

Шаг 1: Создание и базовые операции с картами
Цель: Научиться создавать карты и выполнять основные операции.
Теория:
Карта создается с помощью make(map[тип_ключа]тип_значения)
Или с помощью литерала: map[тип_ключа]тип_значения{ключ: значение, ...}

Операции:
Добавление/изменение: карта[ключ] = значение
Получение: значение = карта[ключ]
Удаление: delete(карта, ключ)
Проверка существования: значение, существует = карта[ключ]

Практика:
go
package main

import "fmt"

func main() {
    // Способ 1: Создание с помощью make (пустая карта)
    возраст := make(map[string]int)
    
    // Добавление элементов
    возраст["Анна"] = 25
    возраст["Борис"] = 30
    возраст["Виктор"] = 28
    
    // Способ 2: Создание с инициализацией
    оценки := map[string]int{
        "Математика": 5,
        "Физика":     4,
        "История":    3,
        "Литература": 5,
    }
    
    // Способ 3: Создание nil-карты (нулевая карта)
    // var телефоннаяКнига map[string]string
    // телефоннаяКнига["Иван"] = "123" // ПАНИКА! Нельзя добавлять в nil-карту
    
    // Правильно: сначала создать через make
    телефоннаяКнига := make(map[string]string)
    телефоннаяКнига["Иван"] = "+7-999-123-45-67"
    
    fmt.Println("Карта возраста:", возраст)
    fmt.Println("Карта оценок:", оценки)
    fmt.Println("Телефонная книга:", телефоннаяКнига)
    
    // Получение значения по ключу
    fmt.Println("\n--- Получение значений ---")
    fmt.Println("Возраст Анны:", возраст["Анна"])
    fmt.Println("Оценка по математике:", оценки["Математика"])
    
    // Если ключа нет - возвращается нулевое значение типа
    fmt.Println("Возраст несуществующего человека:", возраст["Николай"]) // 0
    
    // Проверка существования ключа
    fmt.Println("\n--- Проверка существования ключа ---")
    if возрастАнны, существует := возраст["Анна"]; существует {
        fmt.Println("Анна найдена, возраст:", возрастАнны)
    } else {
        fmt.Println("Анна не найдена в карте")
    }
    
    if возрастНиколая, существует := возраст["Николай"]; существует {
        fmt.Println("Николай найден, возраст:", возрастНиколая)
    } else {
        fmt.Println("Николай не найден в карте")
    }
    
    // Изменение значения
    fmt.Println("\n--- Изменение значений ---")
    fmt.Println("Оценка по истории до изменения:", оценки["История"])
    оценки["История"] = 4
    fmt.Println("Оценка по истории после изменения:", оценки["История"])
    
    // Удаление элемента
    fmt.Println("\n--- Удаление элементов ---")
    fmt.Println("Карта до удаления:", оценки)
    delete(оценки, "Физика")
    fmt.Println("Карта после удаления Физики:", оценки)
    
    // Попытка удалить несуществующий ключ - ошибки не будет
    delete(оценки, "Химия")
    fmt.Println("После попытки удалить Химию:", оценки)
    
    // Длина карты (количество элементов)
    fmt.Println("\n--- Длина карты ---")
    fmt.Println("Количество людей в карте возраста:", len(возраст))
    fmt.Println("Количество предметов в карте оценок:", len(оценки))
}

Объяснение:
make(map[string]int) — создает пустую карту, где ключи типа string, значения типа int.
Литерал карты — map[string]int{"ключ": значение} удобен для инициализации с данными.
nil-карта — неинициализированная карта, в которую нельзя добавлять элементы (вызовет панику).
Проверка существования — значение, существует := карта[ключ] возвращает два значения: само значение и булев флаг.
delete(карта, ключ) — удаляет пару ключ-значение. Не вызывает ошибки, если ключа нет.
len(карта) — возвращает количество пар в карте.

Задание для самостоятельной работы 1:
Создайте карту для хранения столиц стран:
Россия → Москва
США → Вашингтон
Франция → Париж
Япония → Токио

Добавьте 3 свои страны
Запросите у пользователя название страны и выведите столицу
Если страны нет в карте, предложите добавить ее
Реализуйте удаление страны по желанию пользователя

Шаг 2: Перебор карт и вложенные структуры
Цель: Научиться перебирать карты и работать со сложными значениями.
Теория:
Карты перебираются с помощью цикла for range
Порядок перебора не гарантирован (случайный)
Значениями карт могут быть любые типы, включая другие карты, срезы, структуры

Практика:
go
package main

import "fmt"

func main() {
    // Карта с простыми значениями
    население := map[string]int{
        "Москва":       12615,
        "Санкт-Петербург": 5398,
        "Новосибирск":  1625,
        "Екатеринбург": 1493,
        "Казань":       1257,
    }
    
    // Перебор карты
    fmt.Println("--- Перебор карты городов ---")
    for город, численность := range население {
        fmt.Printf("%-20s: %d тыс. человек\n", город, численность)
    }
    
    // Перебор только ключей
    fmt.Println("\n--- Список всех городов ---")
    for город := range население {
        fmt.Println("-", город)
    }
    
    // Сложные значения: карта карт
    fmt.Println("\n--- Карта карт: студенты и их оценки ---")
    
    студенты := map[string]map[string]int{
        "Анна": {
            "Математика": 5,
            "Физика":     4,
            "Химия":      5,
        },
        "Борис": {
            "Математика": 3,
            "Физика":     5,
            "Химия":      4,
        },
        "Виктор": {
            "Математика": 4,
            "Физика":     4,
            "Химия":      3,
        },
    }
    
    // Перебор вложенных карт
    for имя, оценки := range студенты {
        fmt.Printf("\n%s:\n", имя)
        for предмет, оценка := range оценки {
            fmt.Printf("  %-12s: %d\n", предмет, оценка)
        }
    }
    
    // Карта срезами
    fmt.Println("\n--- Карта срезами: покупки по категориям ---")
    
    покупки := map[string][]string{
        "Молочные": {"Молоко", "Сыр", "Йогурт", "Творог"},
        "Овощи":    {"Картофель", "Морковь", "Лук", "Помидоры"},
        "Фрукты":   {"Яблоки", "Бананы", "Апельсины"},
        "Хлеб":     {"Хлеб", "Булочки", "Батон"},
    }
    
    for категория, товары := range покупки {
        fmt.Printf("%s (%d товаров): ", категория, len(товары))
        for i, товар := range товары {
            if i > 0 {
                fmt.Print(", ")
            }
            fmt.Print(товар)
        }
        fmt.Println()
    }
    
    // Практический пример: частотный анализ
    fmt.Println("\n--- Частотный анализ текста ---")
    
    текст := "программирование на языке программирования го это интересно и программирование это весело"
    слова := []string{"программирование", "на", "языке", "программирования", "го", "это", 
                      "интересно", "и", "программирование", "это", "весело"}
    
    частотность := make(map[string]int)
    
    // Подсчет частоты слов
    for _, слово := range слова {
        частотность[слово]++
    }
    
    fmt.Println("Частотность слов:")
    for слово, частота := range частотность {
        fmt.Printf("%-15s: %d раз\n", слово, частота)
    }
}

Объяснение:
for город, численность := range население — перебирает все пары ключ-значение в карте.
for город := range население — перебирает только ключи (если значение не нужно).
Вложенные карты — map[string]map[string]int означает: карта, где ключи — строки, значения — карты (строки → int).
Карта срезов — map[string][]string позволяет хранить несколько значений для одного ключа.
частотность[слово]++ — если ключа нет, он создается со значением 0, затем инкрементируется до 1.

Задание для самостоятельной работы 2:
Создайте карту для подсчета оценок студентов:
Ключ: имя студента
Значение: карта предмет→оценка
Добавьте 5 студентов с 3-4 предметами каждый

Реализуйте функции:
Добавление новой оценки студенту
Расчет среднего балла для каждого студента
Поиск студента с наивысшим средним баллом
Выведите таблицу успеваемости

Шаг 3: Сравнение и копирование карт
Цель: Понять особенности сравнения карт и научиться создавать их копии.
Теория:
Карты являются ссылочными типами (как срезы)
При присваивании одной карты другой создается ссылка на те же данные
Для создания настоящей копии нужно копировать элементы вручную
Карты можно сравнивать только с nil, напрямую сравнение == не работает

Практика:
go
package main

import "fmt"

func main() {
    // Создаем карту
    оригинал := map[string]int{
        "январь":   31,
        "февраль":  28,
        "март":     31,
        "апрель":   30,
    }
    
    fmt.Println("Оригинал:", оригинал)
    
    // Присваивание создает ссылку на ту же карту
    ссылка := оригинал
    ссылка["май"] = 31
    
    fmt.Println("После добавления в ссылку:")
    fmt.Println("Оригинал:", оригинал)   // Изменился!
    fmt.Println("Ссылка:  ", ссылка)     // Та же карта
    
    // Создание настоящей копии (вручную)
    копия := make(map[string]int)
    for ключ, значение := range оригинал {
        копия[ключ] = значение
    }
    
    // Изменяем копию
    копия["февраль"] = 29  // Високосный год
    копия["июнь"] = 30
    
    fmt.Println("\nПосле изменений в копии:")
    fmt.Println("Оригинал:", оригинал)  // Не изменился
    fmt.Println("Копия:   ", копия)     // Изменена
    
    // Сравнение карт
    fmt.Println("\n--- Сравнение карт ---")
    
    // Нельзя сравнивать напрямую: if карта1 == карта2 { ... } // Ошибка компиляции
    
    // Функция для сравнения карт
    равны := compareMaps(оригинал, копия)
    if равны {
        fmt.Println("Карты одинаковые")
    } else {
        fmt.Println("Карты разные")
    }
    
    // Сравнение с nil
    var пустаяКарта map[string]int
    fmt.Println("\nПустая карта равна nil?", пустаяКарта == nil) // true
    
    // Инициализированная карта
    инициализированная := make(map[string]int)
    fmt.Println("Инициализированная карта равна nil?", инициализированная == nil) // false
    
    // Проверка на пустоту
    fmt.Println("Пустая карта (nil) имеет длину:", len(пустаяКарта))
    fmt.Println("Инициализированная пустая карта имеет длину:", len(инициализированная))
    
    // Удаление всех элементов (очистка карты)
    fmt.Println("\n--- Очистка карты ---")
    fmt.Println("Копия до очистки:", копия, "длина:", len(копия))
    
    // Способ 1: Перебор и удаление
    for ключ := range копия {
        delete(копия, ключ)
    }
    
    // Способ 2: Переназначение (проще)
    // копия = make(map[string]int)
    
    fmt.Println("Копия после очистки:", копия, "длина:", len(копия))
}

// Функция для сравнения двух карт
func compareMaps(карта1, карта2 map[string]int) bool {
    // Проверка длины
    if len(карта1) != len(карта2) {
        return false
    }
    
    // Проверка всех пар ключ-значение
    for ключ, значение1 := range карта1 {
        if значение2, существует := карта2[ключ]; !существует || значение1 != значение2 {
            return false
        }
    }
    
    return true
}

Объяснение:
Карты — ссылочные типы — присваивание b = a не копирует данные, а создает новую ссылку.
Копирование вручную — единственный способ создать независимую копию.
Сравнение — карты нельзя сравнивать оператором ==, нужно писать свою функцию.
Nil-карта — var m map[string]int создает nil-карту, в которую нельзя добавлять элементы.
Очистка — чтобы удалить все элементы, можно перебрать и удалить или просто создать новую карту.

Задание для самостоятельной работы 3:
Создайте карту контактов (имя → телефон)

Реализуйте функции:
добавитьКонтакт(имя, телефон) — добавляет или обновляет контакт
удалитьКонтакт(имя) — удаляет контакт
найтиТелефон(имя) — возвращает телефон или сообщение об ошибке
экспортВФайл() — возвращает строку со всеми контактами
импортИзФайла(данные) — восстанавливает карту из строки
Протестируйте, что изменения в одной копии не влияют на другую

Шаг 4: Практические применения карт
Цель: Рассмотреть реальные сценарии использования карт.

Пример 1: Кэширование результатов
go
package main

import (
    "fmt"
    "time"
    "math/rand"
)

func main() {
    // Кэш для хранения результатов тяжелых вычислений
    кэш := make(map[int]int)
    
    // Функция с тяжелыми вычислениями (имитация)
    тяжелыеВычисления := func(n int) int {
        // Имитация долгого вычисления
        time.Sleep(100 * time.Millisecond)
        return n * n
    }
    
    // Функция с кэшированием
    вычислитьСКэшем := func(n int) int {
        // Проверяем, есть ли результат в кэше
        if результат, найдено := кэш[n]; найдено {
            fmt.Printf("Результат для %d взят из кэша\n", n)
            return результат
        }
        
        // Вычисляем и сохраняем в кэш
        fmt.Printf("Вычисление для %d...\n", n)
        результат := тяжелыеВычисления(n)
        кэш[n] = результат
        
        return результат
    }
    
    // Тестируем
    fmt.Println("Первое вычисление 5:")
    fmt.Println("Результат:", вычислитьСКэшем(5))
    
    fmt.Println("\nВторое вычисление 5 (должно быть из кэша):")
    fmt.Println("Результат:", вычислитьСКэшем(5))
    
    fmt.Println("\nПервое вычисление 10:")
    fmt.Println("Результат:", вычислитьСКэшем(10))
    
    fmt.Println("\nТретье вычисление 5 (опять из кэша):")
    fmt.Println("Результат:", вычислитьСКэшем(5))
    
    fmt.Println("\nСодержимое кэша:")
    for ключ, значение := range кэш {
        fmt.Printf("%d → %d\n", ключ, значение)
    }
}

Пример 2: Группировка данных
go
package main

import "fmt"

type Студент struct {
    Имя    string
    Группа string
    Возраст int
}

func main() {
    // Список студентов
    студенты := []Студент{
        {"Анна", "Группа А", 20},
        {"Борис", "Группа Б", 21},
        {"Виктор", "Группа А", 22},
        {"Дарья", "Группа Б", 20},
        {"Елена", "Группа А", 21},
        {"Федор", "Группа В", 23},
    }
    
    // Группировка студентов по группам
    студентыПоГруппам := make(map[string][]Студент)
    
    for _, студент := range студенты {
        студентыПоГруппам[студент.Группа] = append(студентыПоГруппам[студент.Группа], студент)
    }
    
    // Вывод сгруппированных данных
    fmt.Println("Студенты по группам:")
    for группа, список := range студентыПоГруппам {
        fmt.Printf("\n%s (%d студентов):\n", группа, len(список))
        for _, студент := range список {
            fmt.Printf("  - %s, %d лет\n", студент.Имя, студент.Возраст)
        }
    }
    
    // Статистика по возрасту
    fmt.Println("\n--- Статистика по возрасту ---")
    
    количествоПоВозрасту := make(map[int]int)
    суммарныйВозраст := 0
    
    for _, студент := range студенты {
        количествоПоВозрасту[студент.Возраст]++
        суммарныйВозраст += студент.Возраст
    }
    
    fmt.Println("Количество студентов каждого возраста:")
    for возраст, количество := range количествоПоВозрасту {
        fmt.Printf("%d лет: %d студент(ов)\n", возраст, количество)
    }
    
    среднийВозраст := float64(суммарныйВозраст) / float64(len(студенты))
    fmt.Printf("\nСредний возраст: %.1f лет\n", среднийВозраст)
}

Пример 3: Словарь синонимов
go
package main

import (
    "fmt"
    "strings"
)

func main() {
    // Словарь синонимов (каждое слово может иметь несколько синонимов)
    синонимы := make(map[string][]string)
    
    // Добавление синонимов
    добавитьСинонимы := func(слова ...string) {
        for i, слово1 := range слова {
            for j, слово2 := range слова {
                if i != j {
                    // Проверяем, нет ли уже такого синонима
                    ужеЕсть := false
                    for _, существующий := range синонимы[слово1] {
                        if существующий == слово2 {
                            ужеЕсть = true
                            break
                        }
                    }
                    
                    if !ужеЕсть {
                        синонимы[слово1] = append(синонимы[слово1], слово2)
                    }
                }
            }
        }
    }
    
    // Заполняем словарь
    добавитьСинонимы("большой", "крупный", "огромный", "громадный")
    добавитьСинонимы("маленький", "небольшой", "крошечный", "малый")
    добавитьСинонимы("быстрый", "скорый", "стремительный")
    добавитьСинонимы("красивый", "прекрасный", "прелестный", "миловидный")
    
    // Поиск синонимов
    найтиСинонимы := func(слово string) []string {
        return синонимы[слово]
    }
    
    // Тестируем
    fmt.Println("Синонимы для 'большой':", найтиСинонимы("большой"))
    fmt.Println("Синонимы для 'быстрый':", найтиСинонимы("быстрый"))
    fmt.Println("Синонимы для 'несуществующего':", найтиСинонимы("несуществующего"))
    
    // Полный словарь
    fmt.Println("\n--- Полный словарь синонимов ---")
    for слово, списокСинонимов := range синонимы {
        fmt.Printf("%-15s: %v\n", слово, списокСинонимов)
    }
    
    // Применение: замена слов в тексте
    fmt.Println("\n--- Замена слов в тексте ---")
    
    текст := "Большой дом стоял на маленьком холме. Быстрый ручей тек рядом."
    слова := strings.Fields(текст)
    
    for i, слово := range слова {
        // Приводим к нижнему регистру для поиска
        словоLower := strings.ToLower(strings.Trim(word, ".,!?;:"))
        
        // Если есть синонимы, заменяем на первый (если он есть)
        if синонимыСлова, найдено := синонимы[словоLower]; найдено && len(синонимыСлова) > 0 {
            // Выбираем синоним (например, первый)
            слова[i] = синонимыСлова[0]
        }
    }
    
    новыйТекст := strings.Join(слова, " ")
    fmt.Println("Оригинал:", текст)
    fmt.Println("С синонимами:", новыйТекст)
}

Задание для самостоятельной работы 4:
Создайте систему учета товаров на складе:
Ключ: артикул товара
Значение: структура с полями (название, количество, цена)

Реализуйте:
Добавление/удаление товаров
Поиск товара по названию (частичное совпадение)
Фильтрацию по количеству (мало на складе)
Расчет общей стоимости всех товаров на складе
Экспорт в CSV-формат

Шаг 5: Продвинутые техники и оптимизация
Цель: Изучить особенности производительности карт и продвинутые паттерны использования.
Особенности производительности:
Карты хэшируют ключи для быстрого доступа
Вместимость карты может расти автоматически
Можно задать начальную вместимость для оптимизации

Практика:
go
package main

import (
    "fmt"
    "time"
)

func main() {
    fmt.Println("--- Сравнение производительности ---")
    
    // Тест 1: Маленькая карта без начальной вместимости
    начало := time.Now()
    маленькаяКарта := make(map[int]int)
    for i := 0; i < 1000; i++ {
        маленькаяКарта[i] = i * 2
    }
    время1 := time.Since(начало)
    
    // Тест 2: Карта с начальной вместимостью
    начало = time.Now()
    картаСВместимостью := make(map[int]int, 1000) // Задаем начальную вместимость
    for i := 0; i < 1000; i++ {
        картаСВместимостью[i] = i * 2
    }
    время2 := time.Since(начало)
    
    fmt.Printf("Карта без вместимости: %v\n", время1)
    fmt.Printf("Карта с вместимостью:  %v\n", время2)
    fmt.Printf("Разница: %.1f%%\n", (float64(время1)-float64(время2))/float64(время1)*100)
    
    // Карта как множество (set)
    fmt.Println("\n--- Карта как множество (set) ---")
    
    // В Go нет встроенного типа "множество", но его можно имитировать картой
    множество := make(map[string]bool)
    
    элементы := []string{"яблоко", "банан", "апельсин", "яблоко", "виноград", "банан"}
    
    for _, элемент := range элементы {
        множество[элемент] = true
    }
    
    fmt.Println("Исходный список:", элементы)
    fmt.Println("Множество (уникальные элементы):")
    for элемент := range множество {
        fmt.Println("-", элемент)
    }
    
    // Операции с множествами
    fmt.Println("\n--- Операции с множествами ---")
    
    множество1 := map[string]bool{"A": true, "B": true, "C": true}
    множество2 := map[string]bool{"B": true, "C": true, "D": true}
    
    // Объединение
    объединение := make(map[string]bool)
    for эл := range множество1 {
        объединение[эл] = true
    }
    for эл := range множество2 {
        объединение[эл] = true
    }
    
    // Пересечение
    пересечение := make(map[string]bool)
    for эл := range множество1 {
        if множество2[эл] {
            пересечение[эл] = true
        }
    }
    
    // Разность (элементы в 1, но не в 2)
    разность := make(map[string]bool)
    for эл := range множество1 {
        if !множество2[эл] {
            разность[эл] = true
        }
    }
    
    fmt.Println("Множество 1:", keys(множество1))
    fmt.Println("Множество 2:", keys(множество2))
    fmt.Println("Объединение:", keys(объединение))
    fmt.Println("Пересечение:", keys(пересечение))
    fmt.Println("Разность (1 \\ 2):", keys(разность))
    
    // Сортировка ключей карты
    fmt.Println("\n--- Сортировка карты по ключам ---")
    
    неупорядоченнаяКарта := map[string]int{
        "зима": 1,
        "весна": 2,
        "лето": 3,
        "осень": 4,
    }
    
    // Карты не гарантируют порядок, но иногда нужно вывести в определенном порядке
    // Для этого нужно отсортировать ключи отдельно
    
    fmt.Println("В случайном порядке:")
    for ключ, значение := range неупорядоченнаяКарта {
        fmt.Printf("%s → %d\n", ключ, значение)
    }
}

// Вспомогательная функция для получения ключей карты
func keys(карта map[string]bool) []string {
    ключи := make([]string, 0, len(карта))
    for ключ := range карта {
        ключи = append(ключи, ключ)
    }
    return ключи
}

Задание для самостоятельной работы 5:
Создайте систему анализа текста:
Подсчет частоты всех слов в тексте
Поиск N самых частых слов
Поиск уникальных слов (встречаются только один раз)
Сравнение двух текстов на схожесть (по общим словам)

Оптимизируйте:
Используйте начальную вместимость для карт
Реализуйте кэширование результатов
Избегайте лишних аллокаций памяти

Итоги урока
Что вы узнали:
Создание карт — make() и литералы
Базовые операции — добавление, получение, удаление, проверка существования
Перебор карт — цикл for range
Вложенные структуры — карты карт, карты срезов
Сравнение карт — написание собственных функций
Копирование — ручное копирование элементов
Практические применения — кэширование, группировка, словари
Производительность — влияние начальной вместимости
Карты как множества — имитация set

Ключевые моменты:
Карты — это пары "ключ-значение"
Быстрый поиск по ключу (O(1) в среднем)
Ключи должны быть сравнимыми типами
Порядок элементов не гарантирован
Карты — ссылочные типы
Нулевое значение карты — nil

Распространенные ошибки:
Доступ к nil-карте — паника при добавлении в nil-карту
Предположение о порядке — карты не упорядочены
Проверка через нулевое значение — if карта[ключ] == 0 может быть ложно для существующего ключа со значением 0
Утечка памяти — большие карты могут не очищаться сборщиком мусора, если есть ссылки

Что практиковать дальше:
JSON и карты — сериализация/десериализация
Потокобезопасность — использование sync.Map для конкурентного доступа
Кастомные ключи — структуры как ключи карт
LRU-кэш — реализация с ограничением размера

Финальный проект:
Создайте систему управления библиотекой с использованием карт:
Книги — карта ISBN → структура Книга
Читатели — карта ID → структура Читатель
Выдачи — карта ISBN → список ID читателей
Поиск — по названию, автору, жанру
Статистика — самые популярные книги, активные читатели
Резервирование — очередь на популярные книги

Совет: Начните с простой структуры и постепенно добавляйте функциональность. Тестируйте на небольших данных, прежде чем переходить к большим объемам.
Помните: карты — один из самых полезных типов данных в Go. Освоив их, вы сможете решать широкий спектр задач эффективно и элегантно. Практикуйтесь, экспериментируйте, и скоро вы будете использовать карты на автомате!